2.2 Attribute Types

Each attribute value is characterized by an attribute name. No more than one
attribute with a given name may appear in any debugging information entry. There
are no limitations on the ordering of attributes within a debugging information
entry.

The attributes are listed in Table 2.2 following.

Table 2.2: Attribute names

----------------------- -------------------------------------------------------
Attribute               Usage
----------------------- -------------------------------------------------------
DW_AT_abstract_origin   Inline instances of inline subprograms
                        Out-of-line instances of inline subprograms
...
----------------------- -------------------------------------------------------

2.5 DWARF Expressions

DWARF expressions describe how to compute a value or specify a location. They
are expressed in terms of DWARF operations that operate on a stack of values.

[non-normative] The evaluation of a DWARF expression can provide the location of
an object, the value of an array bound, the length of a dynamic string, the
desired value itself, and so on.

If the evaluation of a DWARF expression does not encounter an error, then it can
either result in a value (see 2.5.2 DWARF Expression Value) or a location
description (see 2.5.3 DWARF Location Description). When a DWARF expression is
evaluated, it may be specified whether a value or location description is
required as the result kind.

If the evaluation of a DWARF expression encounters an evaluation error, then the
result is an evaluation error.

If a DWARF expression is ill-formed, then the result is undefined.

The following sections detail the rules for when a DWARF expression is
ill-formed or results in an evaluation error.

A DWARF expression is encoded as a stream of operations, each consisting of an
opcode followed by zero or more literal operands. The number of operands is
implied by the opcode.

In addition to the general operations that are defined here, operations that are
specific to location descriptions are defined in Section 2.6 on page 38.

2.5.1 DWARF Expression Evaluation Context

A DWARF expression is evaluated in a context that can include a number of
context elements. If multiple context elements are specified then they must be
self consistent or the result of the evaluation is undefined. The context
elements that can be specified are:

1.  A current result kind

    The kind of result required by the DWARF expression evaluation. If specified
    it can be a location description or a value.

2.  A current thread

    The target architecture thread identifier of the source program thread of
    execution for which a user presented expression is currently being
    evaluated.

    It is required for operations that are related to target architecture
    threads.

    [non-normative] For example, the DW_OP_regval_type operation.

3.  A current call frame

    The target architecture call frame identifier. It identifies a call frame
    that corresponds to an active invocation of a subprogram in the current
    thread. It is identified by its address on the call stack. The address is
    referred to as the Canonical Frame Address (CFA). The call frame information
    is used to determine the CFA for the call frames of the current thread’s
    call stack (see 6.4 Call Frame Information).

    It is required for operations that specify target architecture registers to
    support virtual unwinding of the call stack.

    [non-normative] For example, the DW_OP_*reg* operations.

    If specified, it must be an active call frame in the current thread.
    Otherwise the result is undefined.

    If it is the currently executing call frame, then it is termed the top call
    frame.

4.  A current program location

    The target architecture program location corresponding to the current call
    frame of the current thread.

    The program location of the top call frame is the target architecture
    program counter for the current thread. The call frame information is used
    to obtain the value of the return address register to determine the program
    location of the other call frames (see 6.4 Call Frame Information).

    It is required for the evaluation of location list expressions to select
    amongst multiple program location ranges. It is required for operations that
    specify target architecture registers to support virtual unwinding of the
    call stack (see 6.4 Call Frame Information).

    If specified:

      * If the current call frame is the top call frame, it must be the current
        target architecture program location.

      * If the current call frame F is not the top call frame, it must be the
        program location associated with the call site in the current caller
        frame F that invoked the callee frame.

      * Otherwise the result is undefined.

5.  A current compilation unit

    The compilation unit debug information entry that contains the DWARF
    expression being evaluated.

    It is required for operations that reference debug information associated
    with the same compilation unit, including indicating if such references use
    the 32-bit or 64-bit DWARF format. It can also provide the default address
    space address size if no current target architecture is specified.

    [non-normative] For example, the DW_OP_constx and DW_OP_addrx operations.

    [non-normative] Note that this compilation unit may not be the same as the
    compilation unit determined from the loaded code object corresponding to the
    current program location. For example, the evaluation of the expression E
    associated with a DW_AT_location attribute of the debug information entry
    operand of the DW_OP_call* operations is evaluated with the compilation unit
    that contains E and not the one that contains the DW_OP_call* operation
    expression.

6.  A current target architecture

    The target architecture.

    It is required for operations that specify target architecture specific
    entities.

    [non-normative] For example, target architecture specific entities include
    DWARF register identifiers, DWARF address space identifiers, the default
    address space, and the address space address sizes.

    If specified:

      * If the current frame is specified, then the current target architecture
        must be the same as the target architecture of the current frame.

      * If the current frame is specified and is the top frame, and if the
        current thread is specified, then the current target architecture must
        be the same as the target architecture of the current thread.

      * If the current compilation unit is specified, then the current target
        architecture default address space address size must be the same as the
        address_size field in the header of the current compilation unit and any
        associated entry in the .debug_aranges section.

      * If the current program location is specified, then the current target
        architecture must be the same as the target architecture of any line
        number information entry (see 6.2 Line Number Information) corresponding
        to the current program location.

      * If the current program location is specified, then the current target
        architecture default address space address size must be the same as the
        address_size field in the header of any entry corresponding to the
        current program location in the .debug_addr, .debug_line,
        .debug_rnglists, .debug_rnglists.dwo, .debug_loclists, and
        .debug_loclists.dwo sections.
 
      * Otherwise the result is undefined.

7.  A current object

    The location description of a program object.

    It is required for the DW_OP_push_object_address operation.

    [non-normative] For example, the DW_AT_data_location attribute on type debug
    information entries specifies the program object corresponding to a runtime
    descriptor as the current object when it evaluates its associated
    expression.

    The result is undefined if the location description is invalid (see 2.6
    Location Descriptions).

8.  An initial stack

    This is a list of values that will be pushed on the operation expression
    evaluation stack in the order provided before evaluation of an operation
    expression starts.

    Some debugger information entries have attributes that evaluate their DWARF
    expression value with initial stack entries. In all other cases the initial
    stack is empty.

    The result is undefined if any location descriptions are invalid (see 2.6
    Location Descriptions).

If the evaluation requires a context element that is not specified, then the
result of the evaluation is an error.

[non-normative] A DWARF expression for a location description may be able to be
evaluated without a thread, call frame, program location, or architecture
context. For example, the location of a global variable may be able to be
evaluated without such context. If the expression evaluates with an error then
it may indicate the variable has been optimized and so requires more context.

[non-normative] The DWARF expression for call frame information (see 6.4 Call
Frame Information) operations are restricted to those that do not require the
compilation unit context to be specified.

The DWARF is ill-formed if all the address_size fields in the headers of all the
entries in the .debug_info, .debug_addr, .debug_line, .debug_rnglists,
.debug_rnglists.dwo, .debug_loclists, and .debug_loclists.dwo sections
corresponding to any given program location do not match.
 
2.5.2 General Operations

Operations represent a postfix operation on a simple stack machine.

A value on the stack has a type and a literal value. It can represent a literal
value of any supported base type of the target architecture. The base type
specifies the size, encoding, and endianity of the literal value.

There is a distinguished base type termed the generic type, which is an integral
type that has the size of an address in the target architecture default address
space, a target architecture defined endianity, and unspecified signedness.

[non-normative] The generic type is the same as the unspecified type used for
stack operations defined in DWARF Version 4 and before.

An integral type is a base type that has an encoding of DW_ATE_signed,
DW_ATE_signed_char, DW_ATE_unsigned, DW_ATE_unsigned_char, DW_ATE_boolean, or
any target architecture defined integral encoding in the inclusive range
DW_ATE_lo_user to DW_ATE_hi_user.

Operations can act on entries on the stack, including adding entries and
removing entries.

Evaluation of an expression starts with an empty stack on which the entries from
the initial stack provided by the context are pushed in the order provided. Then
the operations are evaluated, starting with the first operation of the stream.
Evaluation continues until either an operation has an evaluation error, or until
one past the last operation of the stream is reached.

The result of the evaluation is:

  * If an operation has an evaluation error, or an operation evaluates an
    expression that has an evaluation error, then the result is an evaluation
    error.
  
  * If the current result kind specifies a location description, then:
  
      * If the stack is empty, the result is an empty location description.
  
      * If the stack is not empty, then the result is a memory location
        description (See Section 2.6.1.1.2 Memory Location Descriptions). Any
        other entries on the stack are discarded.
  
      * Otherwise the DWARF expression is ill-formed.
  
      > [For further discussion...]
      > Could define this case as returning an implicit location description as
      > if the DW_OP_implicit operation is performed.
  
  * If the current result kind specifies a value, then:
  
      * If the stack is not empty, then the result is the top value on the
        stack. Any other entries on the stack are discarded.
  
      * Otherwise the DWARF expression is ill-formed.
  
  * If the current result kind is not specified, then:
  
      * If the stack is empty, the result is an empty location description.
  
      * Otherwise, the top stack entry is returned. Any other entries on the
        stack are discarded.

An operation expression is encoded as a byte block with some form of prefix that
specifies the byte count. It can be used:

  * as the value of a debugging information entry attribute that is encoded
    using class exprloc (see 7.5.5 Classes and Forms).

  * as the operand to certain operation expression operations.

  * as the operand to certain call frame information operations (see 6.4 Call
    Frame Information).

  * in location list entries (see 2.5.x DWARF Location List Expressions).
 
2.5.2.1  Literal Encodings

The following operations all push a literal value onto the DWARF stack.

Operations other than DW_OP_const_type push a value V with the generic type. If
V is larger than the generic type, then V is truncated to the generic type size
and the low-order bits used.

1.  DW_OP_lit0, DW_OP_lit1, ..., DW_OP_lit31
    DW_OP_lit<N> operations encode an unsigned literal value N from 0 through
    31, inclusive. They push the value N with the generic type.

2.  DW_OP_addr
    The DW_OP_addr operation has a single operand that encodes a machine address
    and whose size is the size of an address on the target machine.

3.  DW_OP_const1u, DW_OP_const2u, DW_OP_const4u, DW_OP_const8u
    DW_OP_const<N>u operations have a single operand that is a 1, 2, 4, or
    8-byte unsigned integer constant U, respectively. They push the value U with
    the generic type.

4.  DW_OP_const1s, DW_OP_const2s, DW_OP_const4s, DW_OP_const8s
    DW_OP_const<N>s operations have a single operand that is a 1, 2, 4, or
    8-byte signed integer constant S, respectively. They push the value S with
    the generic type.

5.  DW_OP_constu
    DW_OP_constu has a single unsigned LEB128 integer operand N. It pushes the
    value N with the generic type.

6.  DW_OP_consts
    DW_OP_consts has a single signed LEB128 integer operand N. It pushes the
    value N with the generic type.

7.  DW_OP_addrx
    The DW_OP_addrx operation has a single operand that encodes an unsigned
    LEB128 value, which is a zero-based index into the .debug_addr section,
    where a machine address is stored. This index is relative to the value of
    the DW_AT_addr_base attribute of the associated compilation unit.

8.  DW_OP_constx
    DW_OP_constx has a single unsigned LEB128 integer operand that represents a
    zero-based index into the .debug_addr section relative to the value of the
    DW_AT_addr_base attribute of the associated compilation unit. The value N in
    the .debug_addr section has the size of the generic type. It pushes the
    value N with the generic type.

    [non-normative] The DW_OP_constx operation is provided for constants that
    require link-time relocation but should not be interpreted by the consumer
    as a relocatable address (for example, offsets to thread-local storage).

9.  DW_OP_const_type
    DW_OP_const_type has three operands. The first is an unsigned LEB128 integer
    DR that represents the byte offset of a debugging information entry D
    relative to the beginning of the current compilation unit, that provides the
    type T of the constant value. The second is a 1-byte unsigned integral
    constant S. The third is a block of bytes B, with a length equal to S.

    TS is the bit size of the type T. The least significant TS bits of B are
    interpreted as a value V of the type D. It pushes the value V with the type
    D.

    The DWARF is ill-formed if D is not a DW_TAG_base_type debugging information
    entry in the current compilation unit, or if TS divided by 8 (the byte size)
    and rounded up to a whole number is not equal to S.

    [non-normative] While the size of the byte block B can be inferred from the
    type D definition, it is encoded explicitly into the operation so that the
    operation can be parsed easily without reference to the .debug_info section.

2.5.2.2 Register Values

The following operations push a value onto the stack that is either the contents
of a register or the result of adding the contents of a register to a given
signed offset. DW_OP_regval_type pushes the contents of the register together
with the given base type, while the other operations push the result of adding
the contents of a register to a given signed offset together with the generic
type.

1.  DW_OP_fbreg
    The DW_OP_fbreg operation provides a signed LEB128 offset from the address
    specified by the location description in the DW_AT_frame_base attribute of
    the current function.

    [non-normative] This is typically a stack pointer register plus or minus
    some offset.

2.  DW_OP_breg0, DW_OP_breg1, ..., DW_OP_breg31
    The single operand of the DW_OP_breg<n> operations provides a signed LEB128
    offset from the contents of the specified register.

3.  DW_OP_bregx
    DW_OP_bregx has two operands. The first is an unsigned LEB128 integer that
    represents a register number R. The second is a signed LEB128 integer that
    represents a byte displacement B.

    The action is the same as for DW_OP_breg<N>, except that R is used as the
    register number and B is used as the byte displacement.
 
4.  DW_OP_regval_type
    DW_OP_regval_type has two operands. The first is an unsigned LEB128 integer
    that represents a register number R. The second is an unsigned LEB128
    integer DR that represents the byte offset of a debugging information entry
    D relative to the beginning of the current compilation unit, that provides
    the type T of the register value.

    > [For further discussion...]
    > Should DWARF allow the type T to be a larger size than the size of the
    > register R? Restricting a larger bit size avoids any issue of conversion
    > as the, possibly truncated, bit contents of the register is simply
    > interpreted as a value of T. If a conversion is wanted it can be done
    > explicitly using a DW_OP_convert operation.
    >
    > GDB has a per register hook that allows a target specific conversion on a
    > register by register basis. It defaults to truncation of bigger registers.
    > Removing use of the target hook does not cause any test failures in common
    > architectures. If the compiler for a target architecture did want some
    > form of conversion, including a larger result type, it could always
    > explicitly use the DW_OP_convert operation.
    >
    > If T is a larger type than the register size, then the default GDB
    > register hook reads bytes from the next register (or reads out of bounds
    > for the last register!). Removing use of the target hook does not cause
    > any test failures in common architectures (except an illegal hand written
    > assembly test). If a target architecture requires this behavior, these
    > extensions allow a composite location description to be used to combine
    > multiple registers.

2.5.2.3 Stack Operations

The following operations manipulate the DWARF stack. Operations that index the
stack assume that the top of the stack (most recently added entry) has index 0.

Each entry on the stack has an associated type.

1.  DW_OP_dup
    The DW_OP_dup operation duplicates the value (including its type identifier)
    at the top of the stack.

2.  DW_OP_drop
    The DW_OP_drop operation pops the value (including its type identifier) at
    the top of the stack.

3.  DW_OP_pick
    DW_OP_pick has a single unsigned 1-byte operand that represents an index I.
    A copy of the stack entry with index I is pushed onto the stack.

4.  DW_OP_over
    DW_OP_over pushes a copy of the entry with index 1.

    [non-normative] This is equivalent to a DW_OP_pick 1 operation.

5.  DW_OP_swap
    The DW_OP_swap operation swaps the top two stack entries. The entry at the
    top of the stack (including its type identifier) becomes the second stack
    entry, and the second entry (including its type identifier) becomes the top
    of the stack.

6.  DW_OP_rot
    The DW_OP_rot operation rotates the first three stack entries. The entry at
    the top of the stack (including its type identifier) becomes the third stack
    entry, the second entry (including its type identifier) becomes the top of
    the stack, and the third entry (including its type identifier) becomes the
    second entry.

7.  DW_OP_deref
    S is the bit size of the generic type divided by 8 (the byte size) and
    rounded up to a whole number. DR is the offset of a hypothetical debug
    information entry D in the current compilation unit for a base type of the
    generic type.

    The operation is equivalent to performing DW_OP_deref_type S, DR.

8.  DW_OP_deref_size
    DW_OP_deref_size has a single 1-byte unsigned integral constant that
    represents a byte result size S.

    TS is the smaller of the generic type bit size and S scaled by 8 (the byte
    size). If TS is smaller than the generic type bit size then T is an unsigned
    integral type of bit size TS, otherwise T is the generic type. DR is the
    offset of a hypothetical debug information entry D in the current
    compilation unit for a base type T.

    > [For further discussion...]
    > Truncating the value when S is larger than the generic type matches what
    > GDB does. This allows the generic type size to not be an integral byte
    > size. It does allow S to be arbitrarily large. Should S be restricted to
    > the size of the generic type rounded up to a multiple of 8?

    The operation is equivalent to performing DW_OP_deref_type S, DR, except if
    T is not the generic type, the value V pushed is zero-extended to the
    generic type bit size and its type changed to the generic type.

9.  DW_OP_deref_type
    DW_OP_deref_type has two operands. The first is a 1-byte unsigned integral
    constant S. The second is an unsigned LEB128 integer DR that represents the
    byte offset of a debugging information entry D relative to the beginning of
    the current compilation unit, that provides the type T of the result value.

    TS is the bit size of the type T.

    [non-normative] While the size of the pushed value V can be inferred from
    the type T, it is encoded explicitly as the operand S so that the operation
    can be parsed easily without reference to the .debug_info section.

    > [For further discussion...]
    > It is unclear why the operand S is needed. Unlike DW_OP_const_type, the
    > size is not needed for parsing. Any evaluation needs to get the base type
    > T to push with the value to know its encoding and bit size.

    It pops one stack entry and treats it as an address. The popped value must
    have an integral type. A value V of TS bits is retrieved from that address
    and pushed on the stack with the type T.

    The DWARF is ill-formed if D is not in the current compilation unit, D is
    not a DW_TAG_base_type debugging information entry, or if TS divided by 8
    (the byte size) and rounded up to a whole number is not equal to S.

    > [For further discussion...]
    > This definition allows the base type to be a bit size since there seems no
    > reason to restrict it.

10. DW_OP_xderef
    DW_OP_xderef pops two stack entries. The first must be an integral type
    value that represents an address A. The second must be an integral type
    value that represents a target architecture specific address space
    identifier AS.

    The address size S is defined as the address bit size of the target
    architecture specific address space that corresponds to AS.

    A is adjusted to S bits by zero extending if necessary, and then treating
    the least significant S bits as an unsigned value A’.

    It creates a location description L with one memory location description SL.
    SL specifies the memory location storage LS that corresponds to AS with a
    bit offset equal to A’ scaled by 8 (the byte size).

    If AS is an address space that is specific to context elements, then LS
    corresponds to the location storage associated with the current context.

    [non-normative] For example, if AS is for per thread storage then LS is the
    location storage for the current thread. Therefore, if L is accessed by an
    operation, the location storage selected when the location description was
    created is accessed, and not the location storage associated with the
    current context of the access operation.

    The DWARF expression is ill-formed if AS is not one of the values defined by
    the target architecture specific DW_ASPACE_* values.

    The value V is retrieved from the location described by L, and pushed on the
    stack with the generic type.

11. DW_OP_xderef_size
    DW_OP_xderef_size has a single 1-byte unsigned integral constant that
    represents a byte result size S.

    It pops two stack entries. The first must be an integral type value that
    represents an address A. The second must be an integral type value that
    represents a target architecture specific address space identifier AS.

    It creates a location description L as described for DW_OP_xderef.

    The value V of size S is retrieved from the location described by L,
    zero-extended, and pushed on the stack with the generic type.

12. DW_OP_xderef_type
    DW_OP_xderef_type has two operands. The first is a 1-byte unsigned integral
    constant S. The second operand is an unsigned LEB128 integer DR that
    represents the byte offset of a debugging information entry D relative to
    the beginning of the current compilation unit, that provides the type T of
    the result value.

    It pops two stack entries. The first must be an integral type value that
    represents an address A. The second must be an integral type value that
    represents a target architecture specific address space identifier AS.

    It creates a location description L as described for DW_OP_xderef.

    The value V is retrieved from the location described by L, and pushed on the
    stack with the type T.

13. DW_OP_push_object_address
    The DW_OP_push_object_address operation pushes the address of the object
    currently being evaluated as part of evaluation of a user presented
    expression. This object may correspond to an independent variable described
    by its own debugging information entry or it may be a component of an array,
    structure, or class whose address has been dynamically determined by an
    earlier step during user expression evaluation.

    [non-normative] This operator provides explicit functionality (especially
    for arrays involving descriptors) that is analogous to the implicit push of
    the base address of a structure prior to evaluation of a
    DW_AT_data_member_location to access a data member of a structure. For an
    example, see Appendix D.2 on page 292.

14. DW_OP_form_tls_address
    The DW_OP_form_tls_address operation pops a value from the stack, which must
    have an integral type identifier, translates this value into an address in
    the thread-local storage for a thread, and pushes the address onto the stack
    together with the generic type identifier. The meaning of the value on the
    top of the stack prior to this operation is defined by the run-time
    environment. If the run-time environment supports multiple thread-local
    storage blocks for a single thread, then the block corresponding to the
    executable or shared library containing this DWARF expression is used.

    [non-normative] Some implementations of C, C++, Fortran, and other
    languages, support a thread-local storage class. Variables with this storage
    class have distinct values and addresses in distinct threads, much as
    automatic variables have distinct values and addresses in each function
    invocation. Typically, there is a single block of storage containing all
    thread-local variables declared in the main executable, and a separate block
    for the variables declared in each shared library. Each thread-local
    variable can then be accessed in its block using an identifier. This
    identifier is typically an offset into the block and pushed onto the DWARF
    stack by one of the DW_OP_const<n><x> operations prior to the
    DW_OP_form_tls_address operation. Computing the address of the appropriate
    block can be complex (in some cases, the compiler emits a function call to
    do it), and difficult to describe using ordinary DWARF location
    descriptions. Instead of forcing complex thread-local storage calculations
    into the DWARF expressions, the DW_OP_form_tls_address allows the consumer
    to perform the computation based on the run-time environment.
 
15. DW_OP_call_frame_cfa
    The DW_OP_call_frame_cfa operation pushes the value of the CFA, obtained
    from the Call Frame Information (see Section 6.4 on page 171).

    [non-normative] Although the value of DW_AT_frame_base can be computed using
    other DWARF expression operators, in some cases this would require an
    extensive location list because the values of the registers used in
    computing the CFA change during a subroutine. If the Call Frame Information
    is present, then it already encodes such changes, and it is space efficient
    to reference that.

[non-normative] Examples illustrating many of these stack operations are found
in Appendix D.1.2 on page 289.

2.5.2.4 Arithmetic and Logical Operations

The following provide arithmetic and logical operations. Operands of an
operation with two operands must have the same type, either the same base type
or the generic type. The result of the operation which is pushed back has the
same type as the type of the operand(s).

If the type of the operands is the generic type, except as otherwise specified,
the arithmetic operations perform addressing arithmetic, that is, unsigned
arithmetic that is performed modulo one plus the largest representable address.

Operations other than DW_OP_abs, DW_OP_div, DW_OP_minus, DW_OP_mul, DW_OP_neg
and DW_OP_plus require integral types of the operand (either integral base type
or the generic type). Operations do not cause an exception on overflow.

1.  DW_OP_abs
    The DW_OP_abs operation pops the top stack entry, interprets it as a signed
    value and pushes its absolute value. If the absolute value cannot be
    represented, the result is undefined.

2.  DW_OP_and
    The DW_OP_and operation pops the top two stack values, performs a bitwise
    and operation on the two, and pushes the result.

3.  DW_OP_div
    The DW_OP_div operation pops the top two stack values, divides the former
    second entry by the former top of the stack using signed division, and
    pushes the result.

4.  DW_OP_minus
    The DW_OP_minus operation pops the top two stack values, subtracts the
    former top of the stack from the former second entry, and pushes the result.

5.  DW_OP_mod
    The DW_OP_mod operation pops the top two stack values and pushes the result
    of the calculation: former second stack entry modulo the former top of the
    stack.

6.  DW_OP_mul
    The DW_OP_mul operation pops the top two stack entries, multiplies them
    together, and pushes the result.

7.  DW_OP_neg
    The DW_OP_neg operation pops the top stack entry, interprets it as a signed
    value and pushes its negation. If the negation cannot be represented, the
    result is undefined.

8.  DW_OP_not
    The DW_OP_not operation pops the top stack entry, and pushes its bitwise
    complement.

9.  DW_OP_or
    The DW_OP_or operation pops the top two stack entries, performs a bitwise or
    operation on the two, and pushes the result.

10. DW_OP_plus
    The DW_OP_plus operation pops the top two stack entries, adds them together,
    and pushes the result.

11. DW_OP_plus_uconst
    The DW_OP_plus_uconst operation pops the top stack entry, adds it to the
    unsigned LEB128 constant operand interpreted as the same type as the operand
    popped from the top of the stack and pushes the result.

    [non-normative] This operation is supplied specifically to be able to encode
    more field offsets in two bytes than can be done with “DW_OP_lit<n>
    DW_OP_plus.”

12. DW_OP_shl
    The DW_OP_shl operation pops the top two stack entries, shifts the former
    second entry left (filling with zero bits) by the number of bits specified
    by the former top of the stack, and pushes the result.

13. DW_OP_shr
    The DW_OP_shr operation pops the top two stack entries, shifts the former
    second entry right logically (filling with zero bits) by the number of bits
    specified by the former top of the stack, and pushes the result.

14. DW_OP_shra
    The DW_OP_shra operation pops the top two stack entries, shifts the former
    second entry right arithmetically (divide the magnitude by 2, keep the same
    sign for the result) by the number of bits specified by the former top of
    the stack, and pushes the result.

15. DW_OP_xor
    The DW_OP_xor operation pops the top two stack entries, performs a bitwise
    exclusive-or operation on the two, and pushes the result.

2.5.2.5 Control Flow Operations

The following operations provide simple control of the flow of a DWARF
expression.

1.  DW_OP_le, DW_OP_ge, DW_OP_eq, DW_OP_lt, DW_OP_gt, DW_OP_ne
    The six relational operators each:

      * pop the top two stack values, which have the same type, either the same
        base type or the generic type,

      * compare the operands:
        < former second entry >< relational operator >< former top entry >

      * push the constant value 1 onto the stack if the result of the operation
        is true or the constant value 0 if the result of the operation is false.
        The pushed value has the generic type.

    If the operands have the generic type, the comparisons are performed as
    signed operations.

2.  DW_OP_skip
    DW_OP_skip is an unconditional branch. Its single operand is a 2-byte signed
    integer constant. The 2-byte constant is the number of bytes of the DWARF
    expression to skip forward or backward from the current operation, beginning
    after the 2-byte constant.

    If the updated position is at one past the end of the last operation, then
    the operation expression evaluation is complete.

    Otherwise, the DWARF expression is ill-formed if the updated operation
    position is not in the range of the first to last operation inclusive, or
    not at the start of an operation.

3.  DW_OP_bra
    DW_OP_bra is a conditional branch. Its single operand is a 2-byte signed
    integer constant. This operation pops the top of stack. If the value popped
    is not the constant 0, the 2-byte constant operand is the number of bytes of
    the DWARF expression to skip forward or backward from the current operation,
    beginning after the 2-byte constant.

    If the updated position is at one past the end of the last operation, then
    the operation expression evaluation is complete.

    Otherwise, the DWARF expression is ill-formed if the updated operation
    position is not in the range of the first to last operation inclusive, or
    not at the start of an operation.

4.  DW_OP_call2, DW_OP_call4, DW_OP_call_ref
    DW_OP_call2, DW_OP_call4, and DW_OP_call_ref perform DWARF procedure calls
    during evaluation of a DWARF expression.

    DW_OP_call2 and DW_OP_call4, have one operand that is, respectively, a
    2-byte or 4-byte unsigned offset DR that represents the byte offset of a
    debugging information entry D relative to the beginning of the current
    compilation unit.

    DW_OP_call_ref has one operand that is a 4-byte unsigned value in the 32-bit
    DWARF format, or an 8-byte unsigned value in the 64-bit DWARF format, that
    represents the byte offset DR of a debugging information entry D relative to
    the beginning of the .debug_info section that contains the current
    compilation unit. D may not be in the current compilation unit.

    [non-normative] Operand interpretation of DW_OP_call2, DW_OP_call4 and
    DW_OP_call_ref is exactly like that for DW_FORM_ref2, DW_FORM_ref4 and
    DW_FORM_ref_addr, respectively (see Section 7.5.4 on page 207).

    The call operation is evaluated by:

      * If D has a DW_AT_location attribute that is encoded as a exprloc that
        specifies an operation expression E, then execution of the current
        operation expression continues from the first operation of E. Execution
        continues until one past the last operation of E is reached, at which
        point execution continues with the operation following the call
        operation. The operations of E are evaluated with the same current
        context, except current compilation unit is the one that contains D and
        the stack is the same as that being used by the call operation. After
        the call operation has been evaluated, the stack is therefore as it is
        left by the evaluation of the operations of E. Since E is evaluated on
        the same stack as the call operation, E can use, and/or remove entries
        already on the stack, and can add new entries to the stack.

        [non-normative] Values on the stack at the time of the call may be used
        as parameters by the called expression and values left on the stack by
        the called expression may be used as return values by prior agreement
        between the calling and called expressions.

      * Otherwise, there is no effect and no changes are made to the stack.

    > [For further discussion...]
    > In DWARF Version 5, if D does not have a DW_AT_location then DW_OP_call*
    > is defined to have no effect. It is unclear that this is the right
    > definition as a producer should be able to rely on using DW_OP_call* to
    > get a location description for any non-DW_TAG_dwarf_procedure debugging
    > information entries. Also, the producer should not be creating DWARF with
    > DW_OP_call* to a DW_TAG_dwarf_procedure that does not have a
    > DW_AT_location attribute. So, should this case be defined as an ill-formed
    > DWARF expression?

    [non-normative] The DW_TAG_dwarf_procedure debugging information entry can
    be used to define DWARF procedures that can be called.

2.5.2.6 Type Conversions

The following operations provides for explicit type conversion.

1.  DW_OP_convert
    The DW_OP_convert operation pops the top stack entry, converts it to a
    different type, then pushes the result. It takes one operand, which is an
    unsigned LEB128 integer that represents the offset of a debugging
    information entry in the current compilation unit, or value 0 which
    represents the generic type. If the operand is non-zero, the referenced
    entry must be a DW_TAG_base_type entry that provides the type to which the
    value is converted.

2.  DW_OP_reinterpret
    The DW_OP_reinterpret operation pops the top stack entry, reinterprets the
    bits in its value as a value of a different type, then pushes the result. It
    takes one operand, which is an unsigned LEB128 integer that represents the
    offset of a debugging information entry in the current compilation unit, or
    value 0 which represents the generic type. If the operand is non-zero, the
    referenced entry must be a DW_TAG_base_type entry that provides the type to
    which the value is converted. The type of the operand and result type must
    have the same size in bits.

2.5.2.7 Special Operations

There are these special operations currently defined:

1.  DW_OP_nop
    The DW_OP_nop operation is a place holder. It has no effect on the location
    stack or any of its values.

2.  DW_OP_entry_value
    DW_OP_entry_value pushes the value of an expression that is evaluated in the
    context of the calling frame.

    [non-normative] It may be used to determine the value of arguments on entry
    to the current call frame provided they are not clobbered.

    It has two operands. The first is an unsigned LEB128 integer S. The second
    is a block of bytes, with a length equal S, interpreted as a DWARF operation
    expression E.

    E is evaluated with the current context, with the following modifications:
    the result kind is unspecified, the call frame is the one that called the
    current frame, the program location is the call site in the calling frame,
    the object is unspecified, and the initial stack is empty. The calling frame
    information is obtained by virtually unwinding the current call frame using
    the call frame information (see 6.4 Call Frame Information).

    If the result of E is a location description L (see 2.5.x.x Register
    Location Description Operations), and the last operation executed by E is a
    DW_OP_reg* for register R with a target architecture specific base type of
    T, then the contents of the register are retrieved as if a DW_OP_deref_type
    DR operation was performed where DR is the offset of a hypothetical debug
    information entry in the current compilation unit for T. The resulting value
    V s pushed on the stack.

    [non-normative] Using DW_OP_reg* provides a more compact form for the case
    where the value was in a register on entry to the subprogram.

    > [For further discussion...]
    > It is unclear how this provides a more compact expression, as
    > DW_OP_regval_type could be used which is marginally larger.

    If the result of E is a value V, then V is pushed on the stack.

    Otherwise, the DWARF expression is ill-formed.

2.6 Location Descriptions

[non-normative] Debugging information must provide consumers a way to find the
location of program variables, determine the bounds of dynamic arrays and
strings, and possibly to find the base address of a subroutine’s stack frame or
the return address of a subroutine. Furthermore, to meet the needs of recent
computer architectures and optimization techniques, debugging information must
be able to describe the location of an object whose location changes over the
object's lifetime, and may reside at multiple locations simultaneously during
parts of an object's lifetime.

Information about the location of program objects is provided by location
descriptions.

Location descriptions can consist of one or more single location descriptions.

A single location description specifies the location storage that holds a
program object and a position within the location storage where the program
object starts. The position within the location storage is expressed as a bit
offset relative to the start of the location storage.

A location storage is a linear stream of bits that can hold values. Each
location storage has a size in bits and can be accessed using a zero-based bit
offset. The ordering of bits within a location storage uses the bit numbering
and direction conventions that are appropriate to the current language on the
target architecture.

There are five kinds of location storage:

1.  memory location storage

    Corresponds to the target architecture memory address spaces.

2.  register location storage

    Corresponds to the target architecture registers.

3.  implicit location storage

    Corresponds to fixed values that can only be read.

4.  undefined location storage

    Indicates no value is available and therefore cannot be read or written.

5.  composite location storage

    Allows a mixture of these where some bits come from one location storage and
    some from another location storage, or from disjoint parts of the same
    location storage.

    > [For further discussion...]
    > It may be better to add an implicit pointer location storage kind used by
    > the DW_OP_implicit_pointer operation. It would specify the debugger
    > information entry and byte offset provided by the operations.

[non-normative] Location descriptions are a language independent representation
of addressing rules.

  * [non-normative] They can be the result of evaluating a debugger information
    entry attribute that specifies an operation expression of arbitrary
    complexity. In this usage they can describe the location of an object as
    long as its lifetime is either static or the same as the lexical block (see
    3.5 Lexical Block Entries) that owns it, and it does not move during its
    lifetime.

  * [non-normative] They can be the result of evaluating a debugger information
    entry attribute that specifies a location list expression. In this usage
    they can describe the location of an object that has a limited lifetime,
    changes its location during its lifetime, or has multiple locations over
    part or all of its lifetime.

If a location description has more than one single location description, the
DWARF expression is ill-formed if the object value held in each single location
description’s position within the associated location storage is not the same
value, except for the parts of the value that are uninitialized.

[non-normative] A location description that has more than one single location
description can only be created by a location list expression that has
overlapping program location ranges, or certain expression operations that act
on a location description that has more than one single location description.
There are no operation expression operations that can directly create a location
description with more than one single location description.

[non-normative] A location description with more than one single location
description can be used to describe objects that reside in more than one piece
of storage at the same time. An object may have more than one location as a
result of optimization. For example, a value that is only read may be promoted
from memory to a register for some region of code, but later code may revert to
reading the value from memory as the register may be used for other purposes.
For the code region where the value is in a register, any change to the object
value must be made in both the register and the memory so both regions of code
will read the updated value.

[non-normative] A consumer of a location description with more than one single
location description can read the object’s value from any of the single location
descriptions (since they all refer to location storage that has the same value),
but must write any changed value to all the single location descriptions.

Updating a location description L by a bit offset B is defined as adding the
value of B to the bit offset of each single location description SL of L. It is
an evaluation error if the updated bit offset of any SL is less than 0 or
greater than or equal to the size of the location storage specified by SL.

The evaluation of an expression may require context elements to create a
location description. If such a location description is accessed, the storage it
denotes is that associated with the context element values specified when the
location description was created, which may differ from the context at the time
it is accessed.

[non-normative] For example, creating a register location description requires
the thread context: the location storage is for the specified register of that
thread. Creating a memory location description for an address space may required
a thread context: the location storage is the memory associated with that
thread.

If any of the context elements required to create a location description change,
the location description becomes invalid and accessing it is undefined.

[non-normative] Examples of context that can invalidate a location description
are:

  * [non-normative] The thread context is required and execution causes the
    thread to terminate.

  * [non-normative] The call frame context is required and further execution
    causes the call frame to return to the calling frame.

  * [non-normative] The program location is required and further execution of
    the thread occurs. That could change the location list entry or call frame
    information entry that applies.

  * [non-normative] An operation uses call frame information:

      * [non-normative] Any of the frames used in the virtual call frame
        unwinding return.

      * [non-normative] The top call frame is used, the program location is used
        to select the call frame information entry, and further execution of the
        thread occurs.

[non-normative] A DWARF expression can be used to compute a location description
for an object. A subsequent DWARF expression evaluation can be given the object
location description as the object context or initial stack context to compute a
component of the object. The final result is undefined if the object location
description becomes invalid between the two expression evaluations.

A change of a thread’s program location may not make a location description
invalid, yet may still render it as no longer meaningful. Accessing such a
location description, or using it as the object context or initial stack context
of an expression evaluation, may produce an undefined result.

[non-normative] For example, a location description may specify a register that
no longer holds the intended program object after a program location change. One
way to avoid such problems is to recompute location descriptions associated with
threads when their program locations change.

Location descriptions are distinguished in a context sensitive manner. As the
value of an attribute, a location description is encoded using class exprloc and
a location list is encoded using class loclist (which serves as an index into a
separate section containing location lists).
 
2.6.1 Undefined Location Description Operations

[non-normative] The undefined location storage represents a piece or all of an
object that is present in the source but not in the object code (perhaps due to
optimization). Neither reading nor writing to the undefined location storage is
meaningful.

An undefined location description specifies the undefined location storage.
There is no concept of the size of the undefined location storage, nor of a bit
offset for an undefined location description. The DW_OP_*piece operations can
implicitly specify an undefined location description, allowing any size and
offset to be specified, and results in a part with all undefined bits.

2.6.2 Memory Location Descriptions

A memory location description consists of a non-empty DWARF expression (see
Section 2.5 on page 26), whose value is the address of a piece or all of an
object or other entity in memory.

2.6.3 Register Location Descriptions

A register location description consists of a register name operation, which
represents a piece or all of an object located in a given register.

[non-normative] Register location descriptions describe an object (or a piece of
an object) that resides in a register, while the opcodes listed in Section
2.5.1.2 on page 28 are used to describe an object (or a piece of an object) that
is located in memory at an address that is contained in a register (possibly
offset by some constant). A register location description must stand alone as
the entire description of an object or a piece of an object.

The following DWARF operations can be used to specify a register location.

[non-normative] Note that the register number represents a DWARF specific
mapping of numbers onto the actual registers of a given architecture. The
mapping should be chosen to gain optimal density and should be shared by all
users of a given architecture. It is recommended that this mapping be defined by
the ABI authoring committee for each architecture.

1.  DW_OP_reg0, DW_OP_reg1, ..., DW_OP_reg31
    The DW_OP_reg<n> operations encode the numbers of up to 32 registers,
    numbered from 0 through 31, inclusive. The target architecture register
    number R corresponds to the N in the operation name.

    The operation is equivalent to performing DW_OP_regx R.

2.  DW_OP_regx
    The DW_OP_regx operation has a single unsigned LEB128 literal operand that
    encodes the name of a register.

[non-normative] These operations name a register location. To fetch the contents
of a register, it is necessary to use one of the register based addressing
operations, such as DW_OP_bregx (Section 2.5.1.2 on page 28).

2.6.4 Implicit Location Descriptions

An implicit location description represents a piece or all of an object which
has no actual location but whose contents are nonetheless either known or known
to be undefined.

The following DWARF operations may be used to specify a value that has no
location in the program but is a known constant or is computed from other
locations and values in the program.

1.  DW_OP_implicit_value
    The DW_OP_implicit_value operation specifies an immediate value using two
    operands: an unsigned LEB128 length, followed by a sequence of bytes of the
    given length that contain the value.

2.  DW_OP_stack_value
    The DW_OP_stack_value operation specifies that the object does not exist in
    memory but its value is nonetheless known and is at the top of the DWARF
    expression stack. In this form of location description, the DWARF expression
    represents the actual value of the object, rather than its location. The
    DW_OP_stack_value operation terminates the expression.

3.  DW_OP_implicit_pointer
    [non-normative] An optimizing compiler may eliminate a pointer, while still
    retaining the value that the pointer addressed. DW_OP_implicit_pointer
    allows a producer to describe this value.

    The DW_OP_implicit_pointer operation specifies that the object is a pointer
    that cannot be represented as a real pointer, even though the value it would
    point to can be described. In this form of location description, the DWARF
    expression refers to a debugging information entry that represents the
    actual value of the object to which the pointer would point. Thus, a
    consumer of the debug information would be able to show the value of the
    dereferenced pointer, even when it cannot show the value of the pointer
    itself.

    The DW_OP_implicit_pointer operation has two operands: a reference to a
    debugging information entry that describes the dereferenced object’s value,
    and a signed number that is treated as a byte offset from the start of that
    value. The first operand is a 4-byte unsigned value in the 32-bit DWARF
    format, or an 8-byte unsigned value in the 64-bit DWARF format (see Section
    7.4 on page 196) that is used as the offset of a debugging information entry
    in the .debug_info section of the current executable or shared object file.
    The second operand is a signed LEB128 number.

    [non-normative] The debugging information entry referenced by a
    DW_OP_implicit_pointer operation is typically a DW_TAG_variable or
    DW_TAG_formal_parameter entry whose DW_AT_location attribute gives a second
    DWARF expression or a location list that describes the value of the object,
    but the referenced entry may be any entry that contains a DW_AT_location or
    DW_AT_const_value attribute (for example, DW_TAG_dwarf_procedure). By using
    the second DWARF expression, a consumer can reconstruct the value of the
    object when asked to dereference the pointer described by the original DWARF
    expression containing the DW_OP_implicit_pointer operation.

[non-normative] DWARF location descriptions are intended to yield the location
of a value rather than the value itself. An optimizing compiler may perform a
number of code transformations where it becomes impossible to give a location
for a value, but it remains possible to describe the value itself. Section
2.6.1.1.3 on page 39 describes operators that can be used to describe the
location of a value when that value exists in a register but not in memory. The
operations in this section are used to describe values that exist neither in
memory nor in a single register.

2.6.5 Composite Location Descriptions

A composite location description describes an object or value which may be
contained in part of a register or stored in more than one location. Each piece
is described by a composition operation, which does not compute a value nor
store any result on the DWARF stack. There may be one or more composition
operations in a single composite location description. A series of such
operations describes the parts of a value in memory address order.

Each composition operation is immediately preceded by a simple location
description which describes the location where part of the resultant value is
contained.

1.  DW_OP_piece
    The DW_OP_piece operation takes a single operand, which is an unsigned
    LEB128 number. The number describes the size in bytes of the piece of the
    object referenced by the preceding simple location description. If the piece
    is located in a register, but does not occupy the entire register, the
    placement of the piece within that register is defined by the ABI.

    [non-normative] Many compilers store a single variable in sets of registers,
    or store a variable partially in memory and partially in registers.
    DW_OP_piece provides a way of describing how large a part of a variable a
    particular DWARF location description refers to.

2.  DW_OP_bit_piece
    The DW_OP_bit_piece operation takes two operands. The first is an unsigned
    LEB128 number that gives the size in bits of the piece. The second is an
    unsigned LEB128 number that gives the offset in bits from the location
    defined by the preceding DWARF location description.

    Interpretation of the offset depends on the location description. If the
    location description is empty, the offset doesn’t matter and the
    DW_OP_bit_piece operation describes a piece consisting of the given number
    of bits whose values are undefined. If the location is a register, the
    offset is from the least significant bit end of the register. If the
    location is a memory address, the DW_OP_bit_piece operation describes a
    sequence of bits relative to the location whose address is on the top of the
    DWARF stack using the bit numbering and direction conventions that are
    appropriate to the current language on the target system. If the location is
    any implicit value or stack value, the DW_OP_bit_piece operation describes a
    sequence of bits using the least significant bits of that value.

[non-normative] DW_OP_bit_piece is used instead of DW_OP_piece when the piece to
be assembled into a value or assigned to is not byte-sized or is not at the
start of a register or addressable unit of memory.

2.6.6 Location Lists

Location lists are used in place of location descriptions whenever the object
whose location is being described can change location during its lifetime.
Location lists are contained in a separate object file section called
.debug_loclists or .debug_loclists.dwo (for split DWARF object files).

A location list is indicated by a location or other attribute whose value is of
class loclist (see Section 7.5.5 on page 212).

[non-normative] This location list representation, the loclist class, and the
related DW_AT_loclists_base attribute are new in DWARF Version 5. Together they
eliminate most or all of the object language relocations previously needed for
location lists.

A location list consists of a series of location list entries. Each location
list entry is one of the following kinds:

  * Bounded location description. This kind of entry provides a location
    description that specifies the location of an object that is valid over a
    lifetime bounded by a starting and ending address. The starting address is
    the lowest address of the address range over which the location is valid.
    The ending address is the address of the first location past the highest
    address of the address range. When the current PC is within the given range,
    the location description may be used to locate the specified object.

    There are several kinds of bounded location description entries which differ
    in the way that they specify the starting and ending addresses.

    The address ranges defined by the bounded location descriptions of a
    location list may overlap. When they do, they describe a situation in which
    an object exists simultaneously in more than one place. If all of the
    address ranges in a given location list do not collectively cover the entire
    range over which the object in question is defined, and there is no
    following default location description, it is assumed that the object is not
    available for the portion of the range that is not covered.

  * Default location description. This kind of entry provides a location
    description that specifies the location of an object that is valid when no
    bounded location description applies.

  * Base address. This kind of entry provides an address to be used as the base
    address for beginning and ending address offsets given in certain kinds of
    bounded location description. The applicable base address of a bounded
    location description entry is the address specified by the closest preceding
    base address entry in the same location list. If there is no preceding base
    address entry, then the applicable base address defaults to the base address
    of the compilation unit (see Section 3.1.1 on page 60).

    In the case of a compilation unit where all of the machine code is contained
    in a single contiguous section, no base address entry is needed.

  * End-of-list. This kind of entry marks the end of the location list.

A location list consists of a sequence of zero or more bounded location
description or base address entries, optionally followed by a default location
entry, and terminated by an end-of-list entry.

Each location list entry begins with a single byte identifying the kind of that
entry, followed by zero or more operands depending on the kind.

In the descriptions that follow, these terms are used for operands:

  * A counted location description operand consists of an unsigned ULEB integer
    giving the length of the location description (see Section 2.6.1 on page 39)
    that immediately follows.

  * An address index operand is the index of an address in the .debug_addr
    section. This index is relative to the value of the DW_AT_addr_base
    attribute of the associated compilation unit. The address given by this kind
    of operand is not relative to the compilation unit base address.

  * A target address operand is an address on the target machine. (Its size is
    the same as used for attribute values of class address, specifically,
    DW_FORM_addr.)

The following entry kinds are defined for use in both split or non-split units:

1.  DW_LLE_end_of_list
    An end-of-list entry contains no further data.

    [non-normative] A series of this kind of entry may be used for padding or
    alignment purposes.

2.  DW_LLE_base_addressx
    This is a form of base address entry that has one unsigned LEB128 operand.
    The operand value is an address index (into the .debug_addr section) that
    indicates the applicable base address used by subsequent DW_LLE_offset_pair
    entries.

3.  DW_LLE_startx_endx
    This is a form of bounded location description entry that has two unsigned
    LEB128 operands. The operand values are address indices (into the
    .debug_addr section). These indicate the starting and ending addresses,
    respectively, that define the address range for which this location is
    valid. These operands are followed by a counted location description.

4.  DW_LLE_startx_length
    This is a form of bounded location description that has two unsigned ULEB
    operands. The first value is an address index (into the .debug_addr section)
    that indicates the beginning of the address range over which the location is
    valid. The second value is the length of the range. These operands are
    followed by a counted location description.

5.  DW_LLE_offset_pair
    This is a form of bounded location description entry that has two unsigned
    LEB128 operands. The values of these operands are the starting and ending
    offsets, respectively, relative to the applicable base address, that define
    the address range for which this location is valid. These operands are
    followed by a counted location description.

6.  DW_LLE_default_location
    The operand is a counted location description which defines where an object
    is located if no prior location description is valid.

The following kinds of location list entries are defined for use only in
non-split DWARF units:

7.  DW_LLE_base_address
    A base address entry has one target address operand. This address is used as
    the base address when interpreting offsets in subsequent location list
    entries of kind DW_LLE_offset_pair.

8.  DW_LLE_start_end
    This is a form of bounded location description entry that has two target
    address operands. These indicate the starting and ending addresses,
    respectively, that define the address range for which the location is valid.
    These operands are followed by a counted location description.

9.  DW_LLE_start_length
    This is a form of bounded location description entry that has one target
    address operand value and an unsigned LEB128 integer operand value. The
    address is the beginning address of the range over which the location
    description is valid, and the length is the number of bytes in that range.
    These operands are followed by a counted location description.

2.12 Segmented Addresses

[non-normative] In some systems, addresses are specified as offsets within a
given segment rather than as locations within a single flat address space.

Any debugging information entry that contains a description of the location of
an object or subroutine may have a DW_AT_segment attribute, whose value is a
location description. The description evaluates to the segment selector of the
item being described. If the entry containing the DW_AT_segment attribute has a
DW_AT_low_pc, DW_AT_high_pc, DW_AT_ranges or DW_AT_entry_pc attribute, or a
location description that evaluates to an address, then those address values
represent the offset portion of the address within the segment specified by
DW_AT_segment.

If an entry has no DW_AT_segment attribute, it inherits the segment value from
its parent entry. If none of the entries in the chain of parents for this entry
back to its containing compilation unit entry have DW_AT_segment attributes,
then the entry is assumed to exist within a flat address space. Similarly, if
the entry has a DW_AT_segment attribute containing an empty location
description, that entry is assumed to exist within a flat address space.

[non-normative] Some systems support different classes of addresses. The address
class may affect the way a pointer is dereferenced or the way a subroutine is
called.

Any debugging information entry representing a pointer or reference type or a
subroutine or subroutine type may have a DW_AT_address_class attribute, whose
value is an integer constant. The set of permissible values is specific to each
target architecture. The value DW_ADDR_none, however, is common to all
encodings, and means that no address class has been specified.

[non-normative] For example, the Intel386 TM processor might use the following
values:

Table 2.7: Example address class codes
-------------- ------ --------------------------------
Name           Value  Meaning
-------------- ------ --------------------------------
DW_ADDR_none   0      no class specified
DW_ADDR_near16 1      16-bit offset, no segment
DW_ADDR_far16  2      16-bit offset, 16-bit segment
DW_ADDR_huge16 3      16-bit offset, 16-bit segment
DW_ADDR_near32 4      32-bit offset, no segment
DW_ADDR_far32  5      32-bit offset, 16-bit segment
-------------- ------ --------------------------------

3.1.1 Full and Partial Compilation Unit Entries

Table 3.1: Language names
------------------ ---------------------
Language name      Meaning
------------------ ---------------------
...
------------------ ---------------------

3.3.5 Low-Level Information

A subroutine or entry point entry may have a DW_AT_return_addr attribute, whose
value is a location description. The location specified is the place where the
return address for the subroutine or entry point is stored.

A subroutine or entry point entry may also have a DW_AT_frame_base attribute,
whose value is a location description that describes the "frame base" for the
subroutine or entry point. If the location description is a simple register
location description, the given register contains the frame base address. If the
location description is a DWARF expression, the result of evaluating that
expression is the frame base address. Finally, for a location list, this
interpretation applies to each location description contained in the list of
location list entries.

[non-normative] The use of one of the DW_OP_reg<n> operations in this context is
equivalent to using DW_OP_breg<n>(0) but more compact. However, these are not
equivalent in general.

[non-normative] The frame base for a subprogram is typically an address relative
to the first unit of storage allocated for the subprogram's stack frame. The
DW_AT_frame_base attribute can be used in several ways:

1.  [non-normative] In subprograms that need location lists to locate local
    variables, the DW_AT_frame_base can hold the needed location list, while all
    variables' location descriptions can be simpler ones involving the frame
    base.

2.  [non-normative] It can be used in resolving "up-level" addressing within
    nested routines. (See also DW_AT_static_link, below)

[non-normative] Some languages support nested subroutines. In such languages, it
is possible to reference the local variables of an outer subroutine from within
an inner subroutine. The DW_AT_static_link and DW_AT_frame_base attributes allow
debuggers to support this same kind of referencing.

If a subroutine or entry point is nested, it may have a DW_AT_static_link
attribute, whose value is a location description that computes the frame base of
the relevant instance of the subroutine that immediately encloses the subroutine
or entry point.

In the context of supporting nested subroutines, the DW_AT_frame_base attribute
value obeys the following constraints:

1.  It computes a value that does not change during the life of the subprogram,
    and

2.  The computed value is unique among instances of the same subroutine.

    [non-normative] For typical DW_AT_frame_base use, this means that a
    recursive subroutine's stack frame must have non-zero size.

[non-normative] If a debugger is attempting to resolve an up-level reference to
a variable, it uses the nesting structure of DWARF to determine which subroutine
is the lexical parent and the DW_AT_static_link value to identify the
appropriate active frame of the parent. It can then attempt to find the
reference within the context of the parent.

3.4.2 Call Site Parameters

The call site entry may own DW_TAG_call_site_parameter debugging information
entries representing the parameters passed to the call. Call site parameter
entries occur in the same order as the corresponding parameters in the source.
Each such entry has a DW_AT_location attribute which is a location description.
This location description describes where the parameter is passed (usually
either some register, or a memory location expressible as the contents of the
stack register plus some offset).

Each DW_TAG_call_site_parameter entry may have a DW_AT_call_value attribute
which is a DWARF expression which when evaluated yields the value of the
parameter at the time of the call.

[non-normative] If it is not possible to avoid registers or memory locations
that might be clobbered by the call in the expression, then the DW_AT_call_value
attribute should not be provided. The reason for the restriction is that the
value of the parameter may be needed in the midst of the callee, where the call
clobbered registers or memory might be already clobbered, and if the consumer is
not assured by the producer it can safely use those values, the consumer can not
safely use the values at all.

For parameters passed by reference, where the code passes a pointer to a
location which contains the parameter, or for reference type parameters, the
DW_TAG_call_site_parameter entry may also have a DW_AT_call_data_location
attribute whose value is a location description and a DW_AT_call_data_value
attribute whose value is a DWARF expression. The DW_AT_call_data_location
attribute describes where the referenced value lives during the call. If it is
just DW_OP_push_object_address, it may be left out. The DW_AT_call_data_value
attribute describes the value in that location. The expression should not use
registers or memory locations that might be clobbered by the call, as it might
be evaluated after virtually unwinding from the called function back to the
caller.

Each call site parameter entry may also have a DW_AT_call_parameter attribute
which contains a reference to a DW_TAG_formal_parameter entry, DW_AT_type
attribute referencing the type of the parameter or DW_AT_name attribute
describing the parameter's name.

[non-normative] Examples using call site entries and related attributes are
found in Appendix D.15 on page 353.

4.1 Data Object Entries

Program variables, formal parameters and constants are represented by debugging
information entries with the tags DW_TAG_variable, DW_TAG_formal_parameter and
DW_TAG_constant, respectively.

[non-normative] The tag DW_TAG_constant is used for languages that have true
named constants.

The debugging information entry for a program variable, formal parameter or
constant may have the following attributes:

1.  A DW_AT_name attribute, whose value is a null-terminated string containing
    the data object name.

    If a variable entry describes an anonymous object (for example an anonymous
    union), the name attribute is omitted or its value consists of a single zero
    byte.

2.  A DW_AT_external attribute, which is a flag, if the name of a variable is 
    visible outside of its enclosing compilation unit.

    [non-normative] The definitions of C++ static data members of structures or
    classes are represented by variable entries flagged as external. Both file
    static and local variables in C and C++ are represented by non-external
    variable entries.

3.  A DW_AT_declaration attribute, which is a flag that indicates whether this
    entry represents a non-defining declaration of an object.

4.  A DW_AT_location attribute, whose value describes the location of a variable
    or parameter at run-time.

    If no location attribute is present in a variable entry representing the
    definition of a variable (that is, with no DW_AT_declaration attribute), or
    if the location attribute is present but has an empty location description
    (as described in Section 2.6 on page 38), the variable is assumed to exist
    in the source code but not in the executable program (but see number 10,
    below).

    In a variable entry representing a non-defining declaration of a variable,
    the location specified supersedes the location specified by the defining
    declaration but only within the scope of the variable entry; if no location
    is specified, then the location specified in the defining declaration
    applies.

    [non-normative] This can occur, for example, for a C or C++ external
    variable (one that is defined and allocated in another compilation unit) and
    whose location varies in the current unit due to optimization.

    The location of a variable may be further specified with a DW_AT_segment
    attribute, if appropriate.

5.  A DW_AT_type attribute describing the type of the variable, constant or
    formal parameter.

6.  If the variable entry represents the defining declaration for a C++ static
    data member of a structure, class or union, the entry has a
    DW_AT_specification attribute, whose value is a reference to the debugging
    information entry representing the declaration of this data member. The
    referenced entry also has the tag DW_TAG_variable and will be a child of
    some class, structure or union type entry.

    If the variable entry represents a non-defining declaration,
    DW_AT_specification may be used to reference the defining declaration of the
    variable. If no DW_AT_specification attribute is present, the defining
    declaration may be found as a global definition either in the current
    compilation unit or in another compilation unit with the DW_AT_external
    attribute.

    Variable entries containing the DW_AT_specification attribute do not need to
    duplicate information provided by the declaration entry referenced by the
    specification attribute. In particular, such variable entries do not need to
    contain attributes for the name or type of the data member whose definition
    they represent.

7.  A DW_AT_variable_parameter attribute, which is a flag, if a formal
    parameter entry represents a parameter whose value in the calling function
    may be modified by the callee. The absence of this attribute implies that
    the parameter's value in the calling function cannot be modified by the
    callee.

8.  A DW_AT_is_optional attribute, which is a flag, if a parameter entry
    represents an optional parameter.

9.  A DW_AT_default_value attribute for a formal parameter entry. The value of
    this attribute may be a constant, or a reference to the debugging
    information entry for a variable, or a reference to a debugging information
    entry containing a DWARF procedure. If the attribute form is of class
    constant, that constant is interpreted as a value whose type is the same as
    the type of the formal parameter. If the attribute form is of class
    reference, and the referenced entry is for a variable, the default value of
    the parameter is the value of the referenced variable. If the reference
    value is 0, no default value has been specified. Otherwise, the attribute
    represents an implicit DW_OP_call_ref to the referenced debugging
    information entry, and the default value of the parameter is the value
    returned by that DWARF procedure, interpreted as a value of the type of the
    formal parameter.

    [non-normative] For a constant form there is no way to express the absence
    of a default value.

10. A DW_AT_const_value attribute for an entry describing a variable or formal
    parameter whose value is constant and not represented by an object in the
    address space of the program, or an entry describing a named constant. (Note
    that such an entry does not have a location attribute.) The value of this
    attribute may be a string or any of the constant data or data block forms,
    as appropriate for the representation of the variable's value. The value is
    the actual constant value of the variable, represented as it would be on the
    target architecture.

    [non-normative] One way in which a formal parameter with a constant value
    and no location can arise is for a formal parameter of an inlined subprogram
    that corresponds to a constant actual parameter of a call that is inlined.

11. A DW_AT_endianity attribute, whose value is a constant that specifies the
    endianity of the object. The value of this attribute specifies an
    ABI-defined byte ordering for the value of the object. If omitted, the
    default endianity of data for the given type is assumed.

    The set of values and their meaning for this attribute is given in Table
    4.1. These represent the default encoding formats as defined by the target
    architecture's ABI or processor definition. The exact definition of these
    formats may differ in subtle ways for different architectures.

    Table 4.1: Endianity attribute values
    ---------------- ----------------------------------------------------------
    Name             Meaning
    ---------------- ----------------------------------------------------------
    DW_END_default   Default endian encoding (equivalent to the
                     absence of a DW_AT_endianity attribute)
    DW_END_big       Big-endian encoding
    DW_END_little    Little-endian encoding
    ---------------- ----------------------------------------------------------

12. A DW_AT_const_expr attribute, constant expression attribute which is a flag,
    if a variable entry represents a C++ object declared with the constexpr
    specifier. This attribute indicates that the variable can be evaluated as a
    compile-time constant.

    [non-normative] In C++, a variable declared with constexpr is implicitly
    const. Such a variable has a DW_AT_type attribute whose value is a reference
    to a debugging information entry describing a const qualified type.

13. A DW_AT_linkage_name attribute for a variable or constant entry as described
    in Section 2.22 on page 56.

4.2 Common Block Entries

A Fortran common block may be described by a debugging information entry with
the tag DW_TAG_common_block.

The common block entry has a DW_AT_name attribute whose value is a
null-terminated string containing the common block name. It may also have a
DW_AT_linkage_name attribute as described in Section 2.22 on page 56.

A common block entry also has a DW_AT_location attribute whose value describes
the location of the beginning of the common block.

The common block entry owns debugging information entries describing the
variables contained within the common block.

[non-normative] Fortran allows each declarer of a common block to independently
define its contents; thus, common blocks are not types.

5.1 Base Type Entries

[non-normative] A base type is a data type that is not defined in terms of other
data types. Each programming language has a set of base types that are
considered to be built into that language.

A base type is represented by a debugging information entry with the tag
DW_TAG_base_type.

A base type entry may have a DW_AT_name attribute whose value is a
null-terminated string containing the name of the base type as recognized by the
programming language of the compilation unit containing the base type entry.

A base type entry has a DW_AT_encoding attribute describing how the base type is
encoded and is to be interpreted. The DW_AT_encoding attribute is described in
Section 5.1.1 following.

A base type entry may have a DW_AT_endianity attribute as described in Section
4.1 on page 97. If omitted, the encoding assumes the representation that is the
default for the target architecture.

A base type entry has a DW_AT_byte_size attribute or a DW_AT_bit_size attribute
whose integer constant value (see Section 2.21 on page 56) is the amount of
storage needed to hold a value of the type.

[non-normative] For example, the C type int on a machine that uses 32-bit
integers is represented by a base type entry with a name attribute whose value
is "int", an encoding attribute whose value is DW_ATE_signed and a byte size
attribute whose value is 4.

If the value of an object of the given type does not fully occupy the storage
described by a byte size attribute, the base type entry may also have a
DW_AT_bit_size and a DW_AT_data_bit_offset attribute, both of whose values are
integer constant values (see Section 2.19 on page 55). The bit size attribute
describes the actual size in bits used to represent values of the given type.
The data bit offset attribute is the offset in bits from the beginning of the
containing storage to the beginning of the value. Bits that are part of the
offset are padding. If this attribute is omitted a default data bit offset of
zero is assumed.

A DW_TAG_base_type entry may have additional attributes that augment certain of
the base type encodings; these are described in the following section.

5.3 Type Modifier Entries

...

A modified type entry describing a pointer or reference type (using
DW_TAG_pointer_type, DW_TAG_reference_type or DW_TAG_rvalue_reference_type) may
have a DW_AT_address_class attribute to describe how objects having the given
pointer or reference type are dereferenced.

...

5.7.3 Derived or Extended Structures, Classes and Interfaces

[non-normative] In C++, a class (or struct) may be "derived from" or be a
"subclass of" another class. In Java, an interface may "extend" one or more
other interfaces, and a class may "extend" another class and/or "implement" one
or more interfaces. All of these relationships may be described using the
following. Note that in Java, the distinction between extends and implements is
implied by the entities at the two ends of the relationship.

A class type or interface type entry that describes a derived, extended or
implementing class or interface owns debugging information entries describing
each of the classes or interfaces it is derived from, extending or implementing,
respectively, ordered as they were in the source program. Each such entry has
the tag DW_TAG_inheritance.

An inheritance entry has a DW_AT_type attribute whose value is a reference to
the debugging information entry describing the class or interface from which the
parent class or structure of the inheritance entry is derived, extended or
implementing.

An inheritance entry for a class that derives from or extends another class or
struct also has a DW_AT_data_member_location attribute, whose value describes
the location of the beginning of the inherited type relative to the beginning
address of the instance of the derived class. If that value is a constant, it is
the offset in bytes from the beginning of the class to the beginning of the
instance of the inherited type. Otherwise, the value must be a location
description. In this latter case, the beginning address of the instance of the
derived class is pushed on the expression stack before the location description
is evaluated and the result of the evaluation is the location of the instance of
the inherited type.

[non-normative] The interpretation of the value of this attribute for inherited
types is the same as the interpretation for data members (see Section 5.7.6
following).

An inheritance entry may have a DW_AT_accessibility attribute. If no
accessibility attribute is present, private access is assumed for an entry of a
class and public access is assumed for an entry of a struct, union or interface.

If the class referenced by the inheritance entry serves as a C++ virtual base
class, the inheritance entry has a DW_AT_virtuality attribute.

[non-normative] For a C++ virtual base, the data member location attribute will
usually consist of a non-trivial location description.

5.7.8 Member Function Entries

A member function is represented by a debugging information entry with the tag
DW_TAG_subprogram. The member function entry may contain the same attributes and
follows the same rules as non-member global subroutine entries (see Section 3.3
on page 75).

In particular, if the member function entry is an instantiation of a member
function template, it follows the same rules as function template instantiations
(see Section 3.3.7 on page 81).

A member function entry may have a DW_AT_accessibility attribute. If no
accessibility attribute is present, private access is assumed for an entry of a
class and public access is assumed for an entry of a structure, union or
interface.

If the member function entry describes a virtual function, then that entry has a
DW_AT_virtuality attribute.

If the member function entry describes an explicit member function, then that
entry has a DW_AT_explicit attribute.

An entry for a virtual function also has a DW_AT_vtable_elem_location attribute
whose value contains a location description yielding the address of the slot for
the function within the virtual function table for the enclosing class. The
address of an object of the enclosing type is pushed onto the expression stack
before the location description is evaluated.

If the member function entry describes a non-static member function, then that
entry has a DW_AT_object_pointer attribute whose value is a reference to the
formal parameter entry that corresponds to the object for which the function is
called. The name attribute of that formal parameter is defined by the current
language (for example, this for C++ or self for Objective C and some other
languages). That parameter also has a DW_AT_artificial attribute whose value is
true.

...

5.14 Pointer to Member Type Entries

[non-normative] In C++, a pointer to a data or function member of a class or
structure is a unique type.

A debugging information entry representing the type of an object that is a
pointer to a structure or class member has the tag DW_TAG_ptr_to_member_type.

If the pointer to member type has a name, the pointer to member entry has a
DW_AT_name attribute, whose value is a null-terminated string containing the
type name.

The pointer to member entry has a DW_AT_type attribute to describe the type of
the class or structure member to which objects of this type may point.

The entry also has a DW_AT_containing_type attribute, whose value is a reference
to a debugging information entry for the class or structure to whose members
objects of this type may point.

The pointer to member entry has a DW_AT_use_location attribute whose value is a
location description that computes the address of the member of the class to
which the pointer to member entry points.

[non-normative] The method used to find the address of a given member of a class
or structure is common to any instance of that class or structure and to any
instance of the pointer or member type. The method is thus associated with the
type entry, rather than with each instance of the type.

The DW_AT_use_location description is used in conjunction with the location
descriptions for a particular object of the given pointer to member type and for
a particular structure or class instance. The DW_AT_use_location attribute
expects two values to be pushed onto the DWARF expression stack before the
DW_AT_use_location description is evaluated. The first value pushed is the value
of the pointer to member object itself. The second value pushed is the base
address of the entire structure or union instance containing the member whose
address is being calculated.

[non-normative] For an expression such as

    object.*mbr_ptr

[non-normative] where mbr_ptr has some pointer to member type, a debugger
should:

1.  [non-normative] Push the value of mbr_ptr onto the DWARF expression stack.

2.  [non-normative] Push the base address of object onto the DWARF expression
    stack.

3.  [non-normative] Evaluate the DW_AT_use_location description given in the
    type of mbr_ptr.

5.18.1 Data Location

[non-normative] Some languages may represent objects using descriptors to hold
information, including a location and/or run-time parameters, about the data
that represents the value for that object.

The DW_AT_data_location attribute may be used with any type that provides one or
more levels of hidden indirection and/or run-time parameters in its
representation. Its value is a location description. The result of evaluating
this description yields the location of the data for an object. When this
attribute is omitted, the address of the data is the same as the address of the
object.

[non-normative] This location description will typically begin with
DW_OP_push_object_address which loads the address of the object which can then
serve as a descriptor in subsequent calculation. For an example using
DW_AT_data_location for a Fortran 90 array, see Appendix D.2.1 on page 292.

6.1.1.1 Contents of the Name Index

The name index must contain an entry for each debugging information entry that
defines a named subprogram, label, variable, type, or namespace, subject to the
following rules:

  * All non-defining declarations (that is, debugging information entries with a
    DW_AT_declaration attribute) are excluded.

  * DW_TAG_namespace debugging information entries without a
    DW_AT_name attribute are included with the name "(anonymous namespace)".

  * All other debugging information entries without a DW_AT_name attribute are
    excluded.

  * DW_TAG_subprogram, DW_TAG_inlined_subroutine, and DW_TAG_label debugging
    information entries without an address attribute (DW_AT_low_pc,
    DW_AT_high_pc, DW_AT_ranges, or DW_AT_entry_pc) are excluded.

  * DW_TAG_variable debugging information entries with a DW_AT_location
    attribute that includes a DW_OP_addr or DW_OP_form_tls_address operator are
    included; otherwise, they are excluded.

  * If a subprogram or inlined subroutine is included, and has a
    DW_AT_linkage_name attribute, there will be an additional index entry for
    the linkage name.

For the purposes of determining whether a debugging information entry has a
particular attribute (such as DW_AT_name), if debugging information entry A has
a DW_AT_specification or DW_AT_abstract_origin attribute pointing to another
debugging information entry B, any attributes of B are considered to be part of
A.

[non-normative] The intent of the above rules is to provide the consumer with
some assurance that looking up an unqualified name in the index will yield all
relevant debugging information entries that provide a defining declaration at
global scope for that name.

[non-normative] A producer may choose to implement additional rules for what
names are placed in the index, and may communicate those rules to a cooperating
consumer via an augmentation string, described below.

6.4.1 Structure of Call Frame Information

DWARF supports virtual unwinding by defining an architecture independent basis
for recording how subprograms save and restore registers during their lifetimes.
This basis must be augmented on some machines with specific information that is
defined by an architecture specific ABI authoring committee, a hardware vendor,
or a compiler producer. The body defining a specific augmentation is referred to
below as the "augmenter."

Abstractly, this mechanism describes a very large table that has the following
structure:

    LOC CFA R0 R1 ... RN
    L0
    L1
    ...
    LN

The first column indicates an address for every location that contains code in a
program. (In shared object files, this is an object-relative offset.) The
remaining columns contain virtual unwinding rules that are associated with the
indicated location.

The CFA column defines the rule which computes the Canonical Frame Address
value; it may be either a register and a signed offset that are added together,
or a DWARF expression that is evaluated.

The remaining columns are labelled by register number. This includes some
registers that have special designation on some architectures such as the PC and
the stack pointer register. (The actual mapping of registers for a particular
architecture is defined by the augmenter.) The register columns contain rules
that describe whether a given register has been saved and the rule to find the
value for the register in the previous frame.

The register rules are:

    undefined
        A register that has this rule has no recoverable value in the previous
        frame. The previous value of this register is the undefined location
        description (see 2.x.x Undefined Location Description Operations).
        
        [non-normative] By convention, the register is not preserved by a
        callee.

    same value
        This register has not been modified from the previous caller frame. 

        If the current frame is the top frame, then the previous value of this
        register is the location description L that specifies one register
        location description SL. SL specifies the register location storage that
        corresponds to the register with a bit offset of 0 for the current
        thread.

        If the current frame is not the top frame, then the previous value of
        this register is the location description obtained using the call frame
        information for the callee frame and callee program location invoked by
        the current caller frame for the same register.

        [non-normative] By convention, the register is preserved by the callee,
        but the callee has not modified it.

    offset(N)
        N is a signed byte offset. The previous value of this register is saved
        at the location description L, where L is the location description of
        the current CFA (see 2.x.x DWARF Operation Expressions) updated with the
        bit offset N scaled by 8 (the byte size).

    val_offset(N)
        N is a signed byte offset. The previous value of this register is the
        memory byte address of the location description L, where L is the
        location description of the current CFA (see 2.5.4 DWARF Operation
        Expressions) updated with the bit offset N scaled by 8 (the byte size).

        The DWARF is ill-formed if the CFA location description is not a memory
        byte address location description, or if the register size does not
        match the size of an address in the target architecture default address
        space.

        [non-normative] Since the CFA location description is required to be a
        memory byte address location description, the value of val_offset(N)
        will also be a memory byte address location description since it is
        offsetting the CFA location description by N bytes. Furthermore, the
        value of val_offset(N) will be a memory byte address in the target
        architecture default address space.

        > [For further discussion...]
        > Should DWARF allow the address size to be a different size to the size
        > of the register? Requiring them to be the same bit size avoids any
        > issue of conversion as the bit contents of the register is simply
        > interpreted as a value of the address.
        >
        > GDB has a per register hook that allows a target specific conversion
        > on a register by register basis. It defaults to truncation of bigger
        > registers, and to actually reading bytes from the next register (or
        > reads out of bounds for the last register) for smaller registers.
        > There are no GDB tests that read a register out of bounds (except an
        > illegal hand written assembly test).

    register(R)
        This register has been stored in another register numbered R.

        The previous value of this register is the location description obtained
        using the call frame information for the current frame and current
        program location for register R.

        The DWARF is ill-formed if the size of this register does not match the
        size of register R or if there is a cyclic dependency in the call frame
        information.

        > [For further discussion...]
        > Should this also allow R to be larger than this register? If so is the
        > value stored in the low order bits and it is undefined what is stored
        > in the extra upper bits?

    expression(E)
        The previous value of this register is located at the location
        description produced by evaluating the DWARF operation expression E (see
        2.5.4 DWARF Operation Expressions).

        E is evaluated with the current context, except the result kind is a
        location description, the compilation unit is unspecified, the object is
        unspecified, and an initial stack comprising the location description of
        the current CFA (see 2.5.4 DWARF Operation Expressions).

    val_expression(E)
        The previous value of this register is located at the implicit location
        description created from the value produced by evaluating the DWARF
        operation expression E (see 2.5.4 DWARF Operation Expressions).

        E is evaluated with the current context, except the result kind is a
        value, the compilation unit is unspecified, the object is unspecified,
        and an initial stack comprising the location description of the current
        CFA (see 2.5.4 DWARF Operation Expressions).

        The DWARF is ill-formed if the resulting value type size does not match
        the register size.

        > [For further discussion...]
        > This has limited usefulness as the DWARF expression E can only produce
        > values up to the size of the generic type. This is due to not allowing
        > any operations that specify a type in a CFI operation expression. This
        > makes it unusable for registers that are larger than the generic type.
        > However, expression(E) can be used to create an implicit location
        > description of any size.

    architectural
        The rule is defined externally to this specification by the augmenter.

[non-normative] This table would be extremely large if actually constructed as
described. Most of the entries at any point in the table are identical to the
ones above them. The whole table can be represented quite compactly by recording
just the differences starting at the beginning address of each subroutine in the
program.

The virtual unwind information is encoded in a self-contained section called
.debug_frame. Entries in a .debug_frame section are aligned on a multiple of the
address size relative to the start of the section and come in two forms: a
Common Information Entry (CIE) and a Frame Description Entry (FDE).

[non-normative] If the range of code addresses for a function is not contiguous,
there may be multiple CIEs and FDEs corresponding to the parts of that function.

A Common Information Entry (CIE) holds information that is shared among many
Frame Description Entries (FDE). There is at least one CIE in every non-empty
.debug_frame section. A CIE contains the following fields, in order:

1.  length (initial length)
    A constant that gives the number of bytes of the CIE structure, not
    including the length field itself (see Section 7.2.2 on page 184). The size
    of the length field plus the value of length must be an integral multiple of
    the address size specified in the address_size field.

2.  CIE_id (4 or 8 bytes, see Section 7.4 on page 196)
    A constant that is used to distinguish CIEs from FDEs.

    In the 32-bit DWARF format, the value of the CIE id in the CIE header is
    0xffffffff; in the 64-bit DWARF format, the value is 0xffffffffffffffff.

3.  version (ubyte)
    A version number (see Section 7.24 on page 238). This number is specific to
    the call frame information and is independent of the DWARF version number.

    The value of the CIE version number is 4.

    > [For further discussion...]
    > Should this be increased to 5?

4.  augmentation (sequence of UTF-8 characters)
    A null-terminated UTF-8 string that identifies the augmentation to this CIE
    or to the FDEs that use it. If a reader encounters an augmentation string
    that is unexpected, then only the following fields can be read:

      * CIE: length, CIE_id, version, augmentation

      * FDE: length, CIE_pointer, initial_location, address_range

    If there is no augmentation, this value is a zero byte.

    [non-normative] The augmentation string allows users to indicate that there
    is additional vendor and target architecture specific information in the CIE
    or FDE which is needed to virtually unwind a stack frame. For example, this
    might be information about dynamically allocated data which needs to be
    freed on exit from the routine.

    [non-normative] Because the .debug_frame section is useful independently of
    any .debug_info section, the augmentation string always uses UTF-8 encoding.

5.  address_size (ubyte)
    The size of a target address in this CIE and any FDEs that use it, in bytes.
    If a compilation unit exists for this frame, its address size must match the
    address size here.

6.  segment_selector_size (ubyte)
    The size of a segment selector in this CIE and any FDEs that use it, in
    bytes.

7.  code_alignment_factor (unsigned LEB128)
    A constant that is factored out of all advance location instructions (see
    Section 6.4.2.1 on page 177). The resulting value is (operand *
    code_alignment_factor).

8.  data_alignment_factor (signed LEB128)
    A constant that is factored out of certain offset instructions (see Sections
    6.4.2.2 on page 177 and 6.4.2.3 on page 179). The resulting value is
    (operand * data_alignment_factor).

9.  return_address_register (unsigned LEB128)
    An unsigned LEB128 constant that indicates which column in the rule table
    represents the return address of the subprogram. Note that this column might
    not correspond to an actual machine register.

    The value of the return address register is used to determine the program
    location of the caller frame. The program location of the top frame is the
    target architecture program counter value of the current thread.

10. initial_instructions (array of ubyte)
    A sequence of rules that are interpreted to create the initial setting of
    each column in the table.

    The default rule for all columns before interpretation of the initial
    instructions is the undefined rule. However, an ABI authoring body or a
    compilation system authoring body may specify an alternate default value for
    any or all columns.

11. padding (array of ubyte)
    Enough DW_CFA_nop instructions to make the size of this entry match the
    length value above.

An FDE contains the following fields, in order:

1.  length (initial length)
    A constant that gives the number of bytes of the header and instruction
    stream for this subprogram, not including the length field itself (see
    Section 7.2.2 on page 184). The size of the length field plus the value of
    length must be an integral multiple of the address size.

2.  CIE_pointer (4 or 8 bytes, see Section 7.4 on page 196)
    A constant offset into the .debug_frame section that denotes the CIE that is
    associated with this FDE.

3.  initial_location (segment selector and target address)
    The address of the first location associated with this table entry. If the
    segment_selector_size field of this FDE's CIE is non-zero, the initial
    location is preceded by a segment selector of the given length.

4.  address_range (target address)
    The number of bytes of program instructions described by this entry.

5.  instructions (array of ubyte)
    A sequence of table defining instructions that are described in Section
    6.4.2.

6.  padding (array of ubyte)
    Enough DW_CFA_nop instructions to make the size of this entry match the
    length value above.

6.4.2 Call Frame Instructions

Each call frame instruction is defined to take 0 or more operands. Some of the
operands may be encoded as part of the opcode (see Section 7.24 on page 238).
The instructions are defined in the following sections.

Some call frame instructions have operands that are encoded as DWARF operation
expressions E (see Section 2.5.1 on page 26). The DWARF operations that can be
used in E have the following restrictions:

  * DW_OP_addrx, DW_OP_call2, DW_OP_call4, DW_OP_call_ref, DW_OP_const_type,
    DW_OP_constx, DW_OP_convert, DW_OP_deref_type, DW_OP_fbreg,
    DW_OP_implicit_pointer, DW_OP_regval_type, DW_OP_reinterpret, and
    DW_OP_xderef_type operations are not allowed because the call frame
    information must not depend on other debug sections.

  * DW_OP_push_object_address is not allowed because there is no object context
    to provide a value to push.

  * DW_OP_call_frame_cfa and DW_OP_entry_value are not allowed because their
    use would be circular.

[non-normative] Call frame instructions to which these restrictions apply
include DW_CFA_def_cfa_expression, DW_CFA_expression, and DW_CFA_val_expression.

6.4.2.1 Row Creation Instructions

...

6.4.2.2 CFA Definition Instructions

1.  DW_CFA_def_cfa
    The DW_CFA_def_cfa instruction takes two unsigned LEB128 operands
    representing a register number R and a (non-factored) byte displacement B.
    The required action is to define the current CFA rule to be equivalent to
    the result of evaluating the DWARF operation expression DW_OP_bregx R, B as
    a location description.

2.  DW_CFA_def_cfa_sf
    The DW_CFA_def_cfa_sf instruction takes two operands: an unsigned LEB128
    value representing a register number R and a signed LEB128 factored byte
    displacement B. The required action is to define the current CFA rule to be
    equivalent to the result of evaluating the DWARF operation expression
    DW_OP_bregx R, B * data_alignment_factor as a location description.

    [non-normative] The action is the same as DW_CFA_def_cfa, except that the
    second operand is signed and factored.

    > [For further discussion...]
    > (ccoutant) I don't see what was wrong with the original DWARF 5
    > description, which simply defines the operation in terms of the
    > preceding one.
    >
    > (ttye) Formally defining what "except that the second operand is signed
    > and factored" means seems clearer.

3.  DW_CFA_def_cfa_register
    The DW_CFA_def_cfa_register instruction takes a single unsigned LEB128
    operand representing a register number R. The required action is to define
    the current CFA rule to be equivalent to the result of evaluating the DWARF
    operation expression DW_OP_bregx R, B as a location description. B is the
    old CFA byte displacement.

    If the subprogram has no current CFA rule, or the rule was defined by a
    DW_CFA_def_cfa_expression instruction, then the DWARF is ill-formed.

4.  DW_CFA_def_cfa_offset
    The DW_CFA_def_cfa_offset instruction takes a single unsigned LEB128 operand
    representing a (non-factored) byte displacement B. The required action is to
    define the current CFA rule to be equivalent to the result of evaluating the
    DWARF operation expression DW_OP_bregx R, B as a location description. R is
    the old CFA register number.

    If the subprogram has no current CFA rule, or the rule was defined by a
    DW_CFA_def_cfa_expression instruction, then the DWARF is ill-formed.

5.  DW_CFA_def_cfa_offset_sf
    The DW_CFA_def_cfa_offset_sf instruction takes a signed LEB128 operand
    representing a factored byte displacement B. The required action is to
    define the current CFA rule to be equivalent to the result of evaluating the
    DWARF operation expression DW_OP_bregx R, B * data_alignment_factor as a
    location description. R is the old CFA register number.

    If the subprogram has no current CFA rule, or the rule was defined by a
    DW_CFA_def_cfa_expression instruction, then the DWARF is ill-formed.

    [non-normative] The action is the same as DW_CFA_def_cfa_offset, except
    that the operand is signed and factored.

6.  DW_CFA_def_cfa_expression
    The DW_CFA_def_cfa_expression instruction takes a single operand encoded as
    a DW_FORM_exprloc value representing a DWARF operation expression E. The
    required action is to define the current CFA rule to be equivalent to the
    result of evaluating E with the current context, except the result kind is a
    location description, the compilation unit is unspecified, the object is
    unspecified, and an empty initial stack.

    [non-normative] See 6.4.2 Call Frame Instructions regarding restrictions on
    the DWARF expression operations that can be used in E.

    The DWARF is ill-formed if the result of evaluating E is not a memory byte
    address location description.

6.4.2.3 Register Rule Instructions

1.  DW_CFA_undefined
    The DW_CFA_undefined instruction takes a single unsigned LEB128 operand
    that represents a register number R. The required action is to set the rule
    for the register specified by R to "undefined."

2.  DW_CFA_same_value
    The DW_CFA_same_value instruction takes a single unsigned LEB128 operand
    that represents a register number R. The required action is to set the rule
    for the register specified by R to "same value."

3.  DW_CFA_offset
	The DW_CFA_offset instruction takes two operands: a register number R
	(encoded with the opcode) and an unsigned LEB128 constant representing a
	factored displacement B. The required action is to change the rule for the
	register specified by R to be an offset(B * data_alignment_factor) rule.

4.  DW_CFA_offset_extended
    The DW_CFA_offset_extended instruction takes two unsigned LEB128 operands
    representing a register number R and a factored displacement B. This
    instruction is identical to DW_CFA_offset, except for the encoding and size
    of the register operand.

5.  DW_CFA_offset_extended_sf
    The DW_CFA_offset_extended_sf instruction takes two operands: an unsigned
    LEB128 value representing a register number R and a signed LEB128 factored
    displacement B. This instruction is identical to DW_CFA_offset_extended,
    except that B is signed.

6.  DW_CFA_val_offset
    The DW_CFA_val_offset instruction takes two unsigned LEB128 operands
    representing a register number R and a factored displacement B. The required
    action is to change the rule for the register indicated by R to be a
    val_offset(B * data_alignment_factor) rule.

7.  DW_CFA_val_offset_sf
    The DW_CFA_val_offset_sf instruction takes two operands: an unsigned LEB128
    value representing a register number R and a signed LEB128 factored
    displacement B. This instruction is identical to DW_CFA_val_offset, except
    that B is signed.

8.  DW_CFA_register
	The DW_CFA_register instruction takes two unsigned LEB128 operands
	representing register numbers R1 and R2 respectively. The required action is
	to set the rule for the register specified by R1 to be a register(R2) rule.

9.  DW_CFA_expression
    The DW_CFA_expression instruction takes two operands: an unsigned LEB128
    value representing a register number R, and a DW_FORM_block value
    representing a DWARF operation expression E. The required action is to
    change the rule for the register specified by R to be an expression(E) rule.

    [non-normative] That is, E computes the location description where the
    register value can be retrieved.

    [non-normative] See Section 6.4.2 on page 176 regarding restrictions on the
    DWARF expression operations that can be used in E.

10. DW_CFA_val_expression
    The DW_CFA_val_expression instruction takes two operands: an unsigned
    LEB128 value representing a register number R, and a DW_FORM_block value
    representing a DWARF operation expression E. The required action is to
    change the rule for the register specified by R to be a val_expression(E)
    rule.
    
    [non-normative] That is, E computes the value of register R.

    [non-normative] See 6.4.2 Call Frame Instructions regarding restrictions on
    the DWARF expression operations that can be used in E.

    If the result of evaluating E is not a value with a base type size that
    matches the register size, then the DWARF is ill-formed.

11. DW_CFA_restore
    The DW_CFA_restore instruction takes a single operand (encoded with the
    opcode) that represents a register number R. The required action is to
    change the rule for the register specified by R to the rule assigned it by
    the initial_instructions in the CIE.

12. DW_CFA_restore_extended
    The DW_CFA_restore_extended instruction takes a single unsigned LEB128
    operand that represents a register number R. This instruction is identical
    to DW_CFA_restore, except for the encoding and size of the register operand.

7.4 32-Bit and 64-Bit DWARF Formats

...

3.  Within the body of the .debug_info section, certain forms of attribute value
    depend on the choice of DWARF format as follows. For the 32-bit DWARF
    format, the value is a 4-byte unsigned integer; for the 64-bit DWARF format,
    the value is an 8-byte unsigned integer.

    ------------------------ ------------------------------
	Form                     Role
    ------------------------ ------------------------------
	DW_FORM_line_strp        offset in .debug_line_str
	DW_FORM_ref_addr         offset in .debug_info
	DW_FORM_sec_offset       offset in a section other than
                             .debug_info or .debug_str
	DW_FORM_strp             offset in .debug_str
    DW_FORM_strp_sup         offset in .debug_str section of a
                             supplementary object file
    DW_OP_call_ref           offset in .debug_info
    DW_OP_implicit_pointer   offset in .debug_info
    ------------------------ ------------------------------

...

7.5.4 Attribute Encodings

The encodings for the attribute names are given in Table 7.5 following.

Table 7.5: Attribute encodings
------------------ ------ -----------------
Attribute name     Value  Classes
------------------ ------ -----------------
...
------------------ ------ -----------------

7.5.5 Classes and Forms

...

  * reference
    There are four types of reference.

      - The first type of reference...

      - The second type of reference can identify any debugging information
        entry within a .debug_info section; in particular, it may refer to an
        entry in a different compilation unit from the unit containing the
        reference, and may refer to an entry in a different shared object file.
        This type of reference (DW_FORM_ref_addr) is an offset from the
        beginning of the .debug_info section of the target executable or shared
        object file, or, for references within a supplementary object file, an
        offset from the beginning of the local .debug_info section; it is
        relocatable in a relocatable object file and frequently relocated in an
        executable or shared object file. In the 32-bit DWARF format, this
        offset is a 4-byte unsigned value; in the 64-bit DWARF format, it is an
        8-byte unsigned value (see Section 7.4 on page 196).

        [non-normative] A debugging information entry that may be referenced by
        another compilation unit using DW_FORM_ref_addr must have a global
        symbolic name.

        [non-normative] For a reference from one executable or shared object
        file to another, the reference is resolved by the debugger to identify
        the executable or shared object file and the offset into that file's
        .debug_info section in the same fashion as the run time loader, either
        when the debug information is first read, or when the reference is used.

7.7 DWARF Expressions and Location Descriptions

7.7.1 DWARF Expressions

A DWARF expression is stored in a block of contiguous bytes. The bytes form a
sequence of operations. Each operation is a 1-byte code that identifies that
operation, followed by zero or more bytes of additional data. The encodings for
the operations are described in Table 7.9.

Table 7.9: DWARF operation encodings
------------ ----- --------- ---------------------------
                   No. of
Operation    Code  Operands  Notes
------------ ----- --------- ---------------------------
...
------------ ----- --------- ---------------------------

7.7.2 Location Descriptions

A location description is used to compute the location of a variable or other
entity.

7.7.3 Location Lists

...

7.12 Source Languages

The encodings of the constants used in the DW_AT_language attribute are given in
Table 7.17. Names marked with † and their associated values are reserved, but
the languages they represent are not well supported. Table 7.17 also shows the
default lower bound, if any, assumed for an omitted DW_AT_lower_bound attribute
in the context of a DW_TAG_subrange_type debugging information entry for each
defined language.

Table 7.17: Language encodings
-------------------- ------ -------------------
Language name        Value  Default Lower Bound
-------------------- ------ -------------------
...
-------------------- ------ -------------------

7.13 Address Class Encodings

The value of the common address class encoding DW_ADDR_none is 0.

7.24 Call Frame Information

In the 32-bit DWARF format, the value of the CIE id in the CIE header is
0xffffffff; in the 64-bit DWARF format, the value is 0xffffffffffffffff.

The value of the CIE version number is 4.

Call frame instructions are encoded in one or more bytes. The primary opcode is
encoded in the high order two bits of the first byte (that is, opcode = byte ≫
6). An operand or extended opcode may be encoded in the low order 6 bits.
Additional operands are encoded in subsequent bytes. The instructions and their
encodings are presented in Table 7.29 on the following page.

Table 7.29: Call frame instruction encodings
--------------------- ------- ------ --------------- ---------------
                      High 2  Low 6
Instruction           Bits    Bits   Operand 1       Operand 2
--------------------- ------- ------ --------------- ---------------
...
--------------------- ------- ------ --------------- ---------------

7.32 Type Signature Computation

Table 7.32: Attributes used in type signature computation
---------------------------------------------------------
...
---------------------------------------------------------

Appendix A

Attributes by Tag Value (Informative)

...

Table A.1: Attributes by tag value
------------------------------ -------------------------------------
TAG name                       Applicable attributes
------------------------------ -------------------------------------
...
------------------------------ -------------------------------------

Appendix D

Examples (Informative)

D.1.3 DWARF Location Description Examples

...

DW_OP_plus_uconst 4
    A structure member is four bytes from the start of the structure instance.
    The base address is assumed to be already on the stack.

...

DW_OP_entry_value 1 DW_OP_reg5 DW_OP_plus_uconst 16
    The address of the memory location is calculated by adding 16 to the value
    contained in register 5 upon entering the current subprogram.

    [non-normative] Note that unlike the previous DW_OP_entry_value examples,
    this one does not end with DW_OP_stack_value.

...

D.2.1 Fortran Simple Array Example

...

-------------------------------------------------------------------------------
! Description for type of 'ap'
!
1$: DW_TAG_array_type
        ! No name, default (Fortran) ordering, default stride
        DW_AT_type(reference to REAL)
        DW_AT_associated(expression=    ! Test 'ptr_assoc' flag
            DW_OP_push_object_address
            DW_OP_lit<n>                ! where n == offset(ptr_assoc)
            DW_OP_plus
            DW_OP_deref
            DW_OP_lit1                  ! mask for 'ptr_assoc' flag
            DW_OP_and)
        DW_AT_data_location(expression= ! Get raw data address
            DW_OP_push_object_address
            DW_OP_lit<n>                ! where n == offset(base)
            DW_OP_plus
            DW_OP_deref)                ! Type of index of array 'ap'
2$:     DW_TAG_subrange_type
            ! No name, default stride
            DW_AT_type(reference to INTEGER)
            DW_AT_lower_bound(expression=
                DW_OP_push_object_address
                DW_OP_lit<n>            ! where n ==
                                        !   offset(desc, dims) +
                                        !   offset(dims_str, lower_bound)
                DW_OP_plus
                DW_OP_deref)
            DW_AT_upper_bound(expression=
                DW_OP_push_object_address
                DW_OP_lit<n>            ! where n ==
                                        !   offset(desc, dims) +
                                        !   offset(dims_str, upper_bound)
                DW_OP_plus
                DW_OP_deref)
!  Note: for the m'th dimension, the second operator becomes
!  DW_OP_lit<n> where
!       n == offset(desc, dims)          +
!                (m-1)*sizeof(dims_str)  +
!                 offset(dims_str, [lower|upper]_bound)
!  That is, the expression does not get longer for each successive
!  dimension (other than to express the larger offsets involved).
3$: DW_TAG_structure_type
        DW_AT_name("array_ptr")
        DW_AT_byte_size(constant sizeof(REAL) + sizeof(desc<1>))
4$:     DW_TAG_member
            DW_AT_name("myvar")
            DW_AT_type(reference to REAL)
            DW_AT_data_member_location(constant 0)
5$:     DW_TAG_member
            DW_AT_name("ap");
            DW_AT_type(reference to 1$)
            DW_AT_data_member_location(constant sizeof(REAL))
6$: DW_TAG_array_type
        ! No name, default (Fortran) ordering, default stride
        DW_AT_type(reference to 3$)
        DW_AT_allocated(expression=       ! Test 'ptr_alloc' flag
            DW_OP_push_object_address
            DW_OP_lit<n>                  ! where n == offset(ptr_alloc)
            DW_OP_plus
            DW_OP_deref
            DW_OP_lit2                    ! Mask for 'ptr_alloc' flag
            DW_OP_and)
        DW_AT_data_location(expression=   ! Get raw data address
            DW_OP_push_object_address
            DW_OP_lit<n>                  ! where n == offset(base)
            DW_OP_plus
            DW_OP_deref)
7$:     DW_TAG_subrange_type
            ! No name, default stride
            DW_AT_type(reference to INTEGER)
            DW_AT_lower_bound(expression=
                DW_OP_push_object_address
                DW_OP_lit<n>              ! where n == ...
                DW_OP_plus
                DW_OP_deref)
            DW_AT_upper_bound(expression=
                DW_OP_push_object_address
                DW_OP_lit<n>              ! where n == ...
                DW_OP_plus
                DW_OP_deref)
8$: DW_TAG_variable
        DW_AT_name("arrayvar")
        DW_AT_type(reference to 6$)
        DW_AT_location(expression=
            ...as appropriate...)         ! Assume static allocation
-------------------------------------------------------------------------------
Figure D.4: Fortran array example: DWARF description

...

D.2.3 Fortran 2008 Assumed-rank Array Example

...

----------------------------------------------------------------------------
10$:  DW_TAG_array_type
        DW_AT_type(reference to real)
        DW_AT_rank(expression=
            DW_OP_push_object_address
            DW_OP_lit<n>
            DW_OP_plus
            DW_OP_deref)
        DW_AT_data_location(expression=
            DW_OP_push_object_address
            DW_OP_lit<n>
            DW_OP_plus
            DW_OP_deref)
11$:     DW_TAG_generic_subrange
            DW_AT_type(reference to integer)
            !   offset of rank in descriptor
            !   offset of data in descriptor
            DW_AT_lower_bound(expression=
            !   Looks up the lower bound of dimension i.
            !   Operation                       ! Stack effect
            !   (implicit)                      ! i
                DW_OP_lit<n>                    ! i sizeof(dim)
                DW_OP_mul                       ! dim[i]
                DW_OP_lit<n>                    ! dim[i] offsetof(dim)
                DW_OP_plus                      ! dim[i]+offset
                DW_OP_push_object_address       ! dim[i]+offsetof(dim) objptr
                DW_OP_plus                      ! objptr.dim[i]
                DW_OP_lit<n>                    ! objptr.dim[i] offsetof(lb)
                DW_OP_plus                      ! objptr.dim[i].lowerbound
                DW_OP_deref)                    ! *objptr.dim[i].lowerbound
            DW_AT_upper_bound(expression=
            !   Looks up the upper bound of dimension i.
                DW_OP_lit<n>                    ! sizeof(dim)
                DW_OP_mul
                DW_OP_lit<n>                    ! offsetof(dim)
                DW_OP_plus
                DW_OP_push_object_address
                DW_OP_plus
                DW_OP_lit<n>                    ! offset of upperbound in dim
                DW_OP_plus
                DW_OP_deref)
            DW_AT_byte_stride(expression=
            !   Looks up the byte stride of dimension i.
                ...
            !   (analogous to DW_AT_upper_bound)
                )
----------------------------------------------------------------------------
Figure D.13: Sample DWARF for the array descriptor in Figure D.12

...

D.2.6 Ada Example

...

----------------------------------------------------------------------------
11$:  DW_TAG_variable
          DW_AT_name("M")
          DW_AT_type(reference to INTEGER)
12$:  DW_TAG_array_type
          ! No name, default (Ada) order, default stride
          DW_AT_type(reference to INTEGER)
13$:      DW_TAG_subrange_type
              DW_AT_type(reference to INTEGER)
              DW_AT_lower_bound(constant 1)
              DW_AT_upper_bound(reference to variable M at 11$)
14$:  DW_TAG_variable
          DW_AT_name("VEC1")
          DW_AT_type(reference to array type at 12$)
      ...
21$:  DW_TAG_subrange_type
          DW_AT_name("TEENY")
          DW_AT_type(reference to INTEGER)
          DW_AT_lower_bound(constant 1)
          DW_AT_upper_bound(constant 100)
      ...
26$:  DW_TAG_structure_type
          DW_AT_name("REC2")
27$:      DW_TAG_member
              DW_AT_name("N")
              DW_AT_type(reference to subtype TEENY at 21$)
              DW_AT_data_member_location(constant 0)
28$:      DW_TAG_array_type
              ! No name, default (Ada) order, default stride
              ! Default data location
              DW_AT_type(reference to INTEGER)
29$:          DW_TAG_subrange_type
                  DW_AT_type(reference to subrange TEENY at 21$)
                  DW_AT_lower_bound(constant 1)
                  DW_AT_upper_bound(reference to member N at 27$)
30$:      DW_TAG_member
              DW_AT_name("VEC2")
              DW_AT_type(reference to array "subtype" at 28$)
              DW_AT_data_member_location(machine=
                  DW_OP_lit<n>                ! where n == offset(REC2, VEC2)
                  DW_OP_plus)
      ...
41$:  DW_TAG_variable
          DW_AT_name("OBJ2B")
          DW_AT_type(reference to REC2 at 26$)
          DW_AT_location(...as appropriate...)
----------------------------------------------------------------------------
Figure D.20: Ada example: DWARF description
