2.2 Attribute Types

Each attribute value is characterized by an attribute name. No more than one
attribute with a given name may appear in any debugging information entry. There
are no limitations on the ordering of attributes within a debugging information
entry.

The attributes are listed in Table 2.2 following.

Table 2.2: Attribute names

----------------------- -------------------------------------------------------
Attribute               Usage
----------------------- -------------------------------------------------------
DW_AT_abstract_origin   Inline instances of inline subprograms
                        Out-of-line instances of inline subprograms
...
DW_AT_address_space     Architecture specific address space (see 2.13 "Address Spaces")
DW_AT_memory_space      Pointer or reference types (see 5.3 "Type Modifier Entries")
                        Data objects (see 4.1 "Data Object Entries")
DW_AT_lanes             SIMD/SIMT lane count (see 3.3.5 "Low-Level Information")
DW_AT_active_lane       SIMT active lanes (see 3.3.5 "Low-Level Information")
DW_AT_lane_pc           SIMT lane program location (see 3.3.5 "Low-Level Information")
DW_AT_vector_size       Base type vector size (see Section 5.1 "Base Type Entries")
----------------------- -------------------------------------------------------

2.5 DWARF Expressions

DWARF expressions describe how to compute a value or specify a location.

[non-normative] The evaluation of a DWARF expression can provide the location of
an object, the value of an array bound, the length of a dynamic string, the
desired value itself, and so on.

If the evaluation of a DWARF expression does not encounter an error, then it can
either result in a value (see 2.5.2 DWARF Expression Value) or a location
description (see 2.5.3 DWARF Location Description). When a DWARF expression is
evaluated, it may be specified whether a value or location description is
required as the result kind.

If a result kind is specified, and the result of the evaluation does not match
the specified result kind, then the implicit conversions described in 2.5.4.4.3
Memory Location Description Operations are performed if valid. Otherwise, the
DWARF expression is ill-formed.

If the evaluation of a DWARF expression encounters an evaluation error, then the
result is an evaluation error.

If a DWARF expression is ill-formed, then the result is undefined.

The following sections detail the rules for when a DWARF expression is
ill-formed or results in an evaluation error.

A DWARF expression can either be encoded as an operation expression (see 2.5.x
DWARF Operation Expressions), or as a location list expression (see 2.5.x DWARF
Location List Expressions).

2.5.1 DWARF Expression Evaluation Context

A DWARF expression is evaluated in a context that can include a number of
context elements. If multiple context elements are specified then they must be
self consistent or the result of the evaluation is undefined. The context
elements that can be specified are:

1.  A current result kind

    The kind of result required by the DWARF expression evaluation. If specified
    it can be a location description or a value.

2.  A current thread

    The target architecture thread identifier. For source languages that are not
    implemented using a SIMD/SIMT execution model, this corresponds to the
    source program thread of execution for which a user presented expression is
    currently being evaluated. For source languages that are implemented using a
    SIMD/SIMT execution model, this together with the current lane corresponds
    to the source program thread of execution and/or concurrent iteration
    execution for which a user presented expression is currently being
    evaluated.

    It is required for operations that are related to target architecture
    threads.

    [non-normative] For example, the DW_OP_regval_type operation, or the
    DW_OP_form_tls_address and DW_OP_form_aspace_address operations when given
    an address space that is target architecture thread specific.

3.  A current lane

    The 0 based SIMD/SIMT lane identifier to be used in evaluating a user
    presented expression. This applies to source languages that are implemented
    for a target architecture using a SIMD/SIMT execution model. SIMD
    implementations map multiple concurrent loop iterations of a source language
    thread of execution to lanes of the target architecture threads. SIMT
    implementations map source language threads of execution to lanes of the
    target architecture threads.

    It is required for operations that are related to SIMD/SIMT lanes.

    [non-normative] For example, the DW_OP_push_lane operation and
    DW_OP_form_aspace_address operation when given an address space that is
    SIMT lane specific.

    If specified, it must be consistent with the value of the DW_AT_lanes
    attribute of the subprogram corresponding to context's frame and program
    location. It is consistent if the value is greater than or equal to 0 and
    less than the, possibly default, value of the DW_AT_lanes attribute.
    Otherwise the result is undefined.

4.  A current call frame

    The target architecture call frame identifier. It identifies a call frame
    that corresponds to an active invocation of a subprogram in the current
    thread. It is identified by its address on the call stack. The address is
    referred to as the Canonical Frame Address (CFA). The call frame information
    is used to determine the CFA for the call frames of the current thread’s
    call stack (see 6.4 Call Frame Information).

    It is required for operations that specify target architecture registers to
    support virtual unwinding of the call stack.

    [non-normative] For example, the DW_OP_*reg* operations.

    If specified, it must be an active call frame in the current thread. If the
    current lane is specified, then that lane must have been active on entry to
    the call frame (see the DW_AT_lane_pc attribute). Otherwise the result is
    undefined.

    If it is the currently executing call frame, then it is termed the top call
    frame.

5.  A current program location

    The target architecture program location corresponding to the current call
    frame of the current thread.

    The program location of the top call frame is the target architecture
    program counter for the current thread. The call frame information is used
    to obtain the value of the return address register to determine the program
    location of the other call frames (see 6.4 Call Frame Information).

    It is required for the evaluation of location list expressions to select
    amongst multiple program location ranges. It is required for operations that
    specify target architecture registers to support virtual unwinding of the
    call stack (see 6.4 Call Frame Information).

    If specified:

    * If the current lane is not specified:

      * If the current call frame is the top call frame, it must be the current
        target architecture program location.

      * If the current call frame F is not the top call frame, it must be the
        program location associated with the call site in the current caller
        frame F that invoked the callee frame.

    * If the current lane is specified and the architecture program location LPC
      computed by the DW_AT_lane_pc attribute for the current lane is not the
      undefined location description (indicating the lane was not active on
      entry to the call frame), it must be LPC.

    * Otherwise the result is undefined.

6.  A current compilation unit

    The compilation unit debug information entry that contains the DWARF
    expression being evaluated.

    It is required for operations that reference debug information associated
    with the same compilation unit, including indicating if such references use
    the 32-bit or 64-bit DWARF format. It can also provide the default address
    space address size if no current target architecture is specified.

    [non-normative] For example, the DW_OP_constx and DW_OP_addrx operations.

    [non-normative] Note that this compilation unit may not be the same as the
    compilation unit determined from the loaded code object corresponding to the
    current program location. For example, the evaluation of the expression E
    associated with a DW_AT_location attribute of the debug information entry
    operand of the DW_OP_call* operations is evaluated with the compilation unit
    that contains E and not the one that contains the DW_OP_call* operation
    expression.

7.  A current target architecture

    The target architecture.

    It is required for operations that specify target architecture specific
    entities.

    [non-normative] For example, target architecture specific entities include
    DWARF register identifiers, DWARF lane identifiers, DWARF address space
    identifiers, the default address space, and the address space address sizes.

    If specified:

      * If the current frame is specified, then the current target architecture
        must be the same as the target architecture of the current frame.

      * If the current frame is specified and is the top frame, and if the
        current thread is specified, then the current target architecture must
        be the same as the target architecture of the current thread.

      * If the current compilation unit is specified, then the current target
        architecture default address space address size must be the same as the
        address_size field in the header of the current compilation unit and any
        associated entry in the .debug_aranges section.

      * If the current program location is specified, then the current target
        architecture must be the same as the target architecture of any line
        number information entry (see 6.2 Line Number Information) corresponding
        to the current program location.

      * If the current program location is specified, then the current target
        architecture default address space address size must be the same as the
        address_size field in the header of any entry corresponding to the
        current program location in the .debug_addr, .debug_line,
        .debug_rnglists, .debug_rnglists.dwo, .debug_loclists, and
        .debug_loclists.dwo sections.
 
      * Otherwise the result is undefined.

8.  A current object

    The location description of a program object.

    It is required for the DW_OP_push_object_address operation.

    [non-normative] For example, the DW_AT_data_location attribute on type debug
    information entries specifies the program object corresponding to a runtime
    descriptor as the current object when it evaluates its associated
    expression.

    The result is undefined if the location description is invalid (see 2.5.3
    DWARF Location Description).

9.  An initial stack

    This is a list of values or location descriptions that will be pushed on
    the operation expression evaluation stack in the order provided before
    evaluation of an operation expression starts.

    Some debugger information entries have attributes that evaluate their DWARF
    expression value with initial stack entries. In all other cases the initial
    stack is empty.

    The result is undefined if any location descriptions are invalid (see 2.5.3
    DWARF Location Description).

10. Target architecture specific information

    [non-normative] For example, the SIMT thread associated with the current
    lane may be needed when accessing target architecture specific address
    spaces that are SIMT thread dependant.

If the evaluation requires a context element that is not specified, then the
result of the evaluation is an error.

[non-normative] A DWARF expression for a location description may be able to be
evaluated without a thread, lane, call frame, program location, or architecture
context. For example, the location of a global variable may be able to be
evaluated without such context. If the expression evaluates with an error then
it may indicate the variable has been optimized and so requires more context.

[non-normative] The DWARF expression for call frame information (see 6.4 Call
Frame Information) operations are restricted to those that do not require the
compilation unit context to be specified.

The DWARF is ill-formed if all the address_size fields in the headers of all the
entries in the .debug_info, .debug_addr, .debug_line, .debug_rnglists,
.debug_rnglists.dwo, .debug_loclists, and .debug_loclists.dwo sections
corresponding to any given program location do not match.
 
2.5.2 DWARF Expression Value

A value has a type and a literal value. It can represent a literal value of any
supported base type of the target architecture. The base type specifies the
size, encoding, and endianity of the literal value.

There is a distinguished base type termed the generic type, which is an integral
type that has the size of an address in the target architecture default address
space, a target architecture defined endianity, and unspecified signedness.

[non-normative] The generic type is the same as the unspecified type used for
stack operations defined in DWARF Version 4 and before.

An integral type is a base type that has an encoding of DW_ATE_signed,
DW_ATE_signed_char, DW_ATE_unsigned, DW_ATE_unsigned_char, DW_ATE_boolean, or
any target architecture defined integral encoding in the inclusive range
DW_ATE_lo_user to DW_ATE_hi_user.

> [For further discussion...]
> It may be desirable to add an implicit pointer base type encoding. It would
> be used for the type of the value that is produced when the DW_OP_deref*
> operation retrieves the full contents of an implicit pointer location storage
> created by the DW_OP_implicit_pointer or DW_OP_aspace_implicit_pointer
> operations. The literal value would record the debugging information entry and
> byte displacement specified by the associated DW_OP_implicit_pointer or
> DW_OP_aspace_implicit_pointer operations.
>
> It is unclear if DW_ATE_address is an integral type. GDB does not seem to
> consider it as integral.

2.5.3 DWARF Location Description

[non-normative] Debugging information must provide consumers a way to find the
location of program variables, determine the bounds of dynamic arrays and
strings, and possibly to find the base address of a subroutine’s stack frame or
the return address of a subroutine. Furthermore, to meet the needs of recent
computer architectures and optimization techniques, debugging information must
be able to describe the location of an object whose location changes over the
object's lifetime, and may reside at multiple locations simultaneously during
parts of an object's lifetime.

Information about the location of program objects is provided by location
descriptions.

Location descriptions can consist of one or more single location descriptions.

A single location description specifies the location storage that holds a
program object and a position within the location storage where the program
object starts. The position within the location storage is expressed as a bit
offset relative to the start of the location storage.

A location storage is a linear stream of bits that can hold values. Each
location storage has a size in bits and can be accessed using a zero-based bit
offset. The ordering of bits within a location storage uses the bit numbering
and direction conventions that are appropriate to the current language on the
target architecture.

There are five kinds of location storage:

1.  memory location storage

    Corresponds to the target architecture memory address spaces.

2.  register location storage

    Corresponds to the target architecture registers.

3.  implicit location storage

    Corresponds to fixed values that can only be read.

4.  undefined location storage

    Indicates no value is available and therefore cannot be read or written.

5.  composite location storage

    Allows a mixture of these where some bits come from one location storage and
    some from another location storage, or from disjoint parts of the same
    location storage.

    > [For further discussion...]
    > It may be better to add an implicit pointer location storage kind used by
    > the DW_OP_implicit_pointer and DW_OP_aspace_implicit_pointer operations.
    > It would specify the debugger information entry and byte offset provided
    > by the operations.

[non-normative] Location descriptions are a language independent representation
of addressing rules.

  * [non-normative] They can be the result of evaluating a debugger information
    entry attribute that specifies an operation expression of arbitrary
    complexity. In this usage they can describe the location of an object as
    long as its lifetime is either static or the same as the lexical block (see
    3.5 Lexical Block Entries) that owns it, and it does not move during its
    lifetime.

  * [non-normative] They can be the result of evaluating a debugger information
    entry attribute that specifies a location list expression. In this usage
    they can describe the location of an object that has a limited lifetime,
    changes its location during its lifetime, or has multiple locations over
    part or all of its lifetime.

If a location description has more than one single location description, the
DWARF expression is ill-formed if the object value held in each single location
description’s position within the associated location storage is not the same
value, except for the parts of the value that are uninitialized.

[non-normative] A location description that has more than one single location
description can only be created by a location list expression that has
overlapping program location ranges, or certain expression operations that act
on a location description that has more than one single location description.
There are no operation expression operations that can directly create a location
description with more than one single location description.

[non-normative] A location description with more than one single location
description can be used to describe objects that reside in more than one piece
of storage at the same time. An object may have more than one location as a
result of optimization. For example, a value that is only read may be promoted
from memory to a register for some region of code, but later code may revert to
reading the value from memory as the register may be used for other purposes.
For the code region where the value is in a register, any change to the object
value must be made in both the register and the memory so both regions of code
will read the updated value.

[non-normative] A consumer of a location description with more than one single
location description can read the object’s value from any of the single location
descriptions (since they all refer to location storage that has the same value),
but must write any changed value to all the single location descriptions.

The evaluation of an expression may require context elements to create a
location description. If such a location description is accessed, the storage it
denotes is that associated with the context element values specified when the
location description was created, which may differ from the context at the time
it is accessed.

[non-normative] For example, creating a register location description requires
the thread context: the location storage is for the specified register of that
thread. Creating a memory location description for an address space may required
a thread and a lane context: the location storage is the memory associated with
that thread and lane.

If any of the context elements required to create a location description change,
the location description becomes invalid and accessing it is undefined.

[non-normative] Examples of context that can invalidate a location description
are:

  * [non-normative] The thread context is required and execution causes the
    thread to terminate.

  * [non-normative] The call frame context is required and further execution
    causes the call frame to return to the calling frame.

  * [non-normative] The program location is required and further execution of
    the thread occurs. That could change the location list entry or call frame
    information entry that applies.

  * [non-normative] An operation uses call frame information:

      * [non-normative] Any of the frames used in the virtual call frame
        unwinding return.

      * [non-normative] The top call frame is used, the program location is used
        to select the call frame information entry, and further execution of the
        thread occurs.

[non-normative] A DWARF expression can be used to compute a location description
for an object. A subsequent DWARF expression evaluation can be given the object
location description as the object context or initial stack context to compute a
component of the object. The final result is undefined if the object location
description becomes invalid between the two expression evaluations.

A change of a thread’s program location may not make a location description
invalid, yet may still render it as no longer meaningful. Accessing such a
location description, or using it as the object context or initial stack context
of an expression evaluation, may produce an undefined result.

[non-normative] For example, a location description may specify a register that
no longer holds the intended program object after a program location change. One
way to avoid such problems is to recompute location descriptions associated with
threads when their program locations change.

2.5.4 DWARF Operation Expressions

An operation expression is comprised of a stream of operations, each consisting
of an opcode followed by zero or more operands. The number of operands is
implied by the opcode.

Operations represent a postfix operation on a simple stack machine.

Each stack entry can hold either a value or a location description.

Operations can act on entries on the stack, including adding entries and
removing entries.

If the kind of a stack entry does not match the kind required by the operation
and is not implicitly convertible to the required kind (see 2.x.x.x Memory
Location Description Operations), then the DWARF operation expression is
ill-formed.

Evaluation of an operation expression starts with an empty stack on which the
entries from the initial stack provided by the context are pushed in the order
provided. Then the operations are evaluated, starting with the first operation
of the stream. Evaluation continues until either an operation has an evaluation
error, or until one past the last operation of the stream is reached.

The result of the evaluation is:

  * If an operation has an evaluation error, or an operation evaluates an
    expression that has an evaluation error, then the result is an evaluation
    error.
  
  * If the current result kind specifies a location description, then:
  
      * If the stack is empty, the result is a location description with one
        undefined location description.

        [non-normative] This rule is for backwards compatibility with DWARF
        Version 5 which has no explicit operation to create an undefined
        location description, and uses an empty operation expression for this
        purpose.

      * If the top stack entry is a location description, or can be converted
        to one (see 2.5.4.4.3 Memory Location Description Operations), then the
        result is that, possibly converted, location description. Any other
        entries on the stack are discarded.
  
      * Otherwise the DWARF expression is ill-formed.
  
      > [For further discussion...]
      > Could define this case as returning an implicit location description as
      > if the DW_OP_implicit operation is performed.
  
  * If the current result kind specifies a value, then:
  
      * If the top stack entry is a value, or can be converted to one (see
        2.5.4.4.3 Memory Location Description Operations), then the result is
        that, possibly converted, value. Any other entries on the stack are
        discarded.

      * Otherwise the DWARF expression is ill-formed.
  
  * If the current result kind is not specified, then:
  
      * If the stack is empty, the result is a location description with one
        undefined location description.

        [non-normative] This rule is for backwards compatibility with DWARF
        Version 5 which has no explicit operation to create an undefined
        location description, and uses an empty operation expression for this
        purpose.

        > [For further discussion...]
        > This rule is consistent with the rule above for when a location
        > description is requested. However, GDB appears to report this as an
        > error and no GDB tests appear to cause an empty stack for this case.
  
      * Otherwise, the top stack entry is returned. Any other entries on the
        stack are discarded.

An operation expression is encoded as a byte block with some form of prefix that
specifies the byte count. It can be used:

  * as the value of a debugging information entry attribute that is encoded
    using class exprloc (see 7.5.5 Classes and Forms).

  * as the operand to certain operation expression operations.

  * as the operand to certain call frame information operations (see 6.4 Call
    Frame Information).

  * in location list entries (see 2.5.x DWARF Location List Expressions).

2.5.4.1 Stack Operations

The following operations manipulate the DWARF stack. Operations that index the
stack assume that the top of the stack (most recently added entry) has index 0.
They allow the stack entries to be either a value or location description.

If any stack entry accessed by a stack operation is an incomplete composite
location description (see 2.x.x Composite Location Description Operations), then
the DWARF expression is ill-formed.

> [For further discussion...]
> If it is desired to also make them work with incomplete composite location
> descriptions, then would need to define that the composite location storage
> specified by the incomplete composite location description is also replicated
> when a copy is pushed. This ensures that each copy of the incomplete composite
> location description can update the composite location storage they specify
> independently.

1.  DW_OP_dup
    DW_OP_dup duplicates the stack entry at the top of the stack.

2.  DW_OP_drop
    DW_OP_drop pops the stack entry at the top of the stack and discards it.

3.  DW_OP_pick
    DW_OP_pick has a single unsigned 1-byte operand that represents an index I.
    A copy of the stack entry with index I is pushed onto the stack.

4.  DW_OP_over
    DW_OP_over pushes a copy of the entry with index 1.

    [non-normative] This is equivalent to a DW_OP_pick 1 operation.

5.  DW_OP_swap
    DW_OP_swap swaps the top two stack entries. The entry at the top of the
    stack becomes the second stack entry, and the second stack entry becomes the
    top of the stack.

6.  DW_OP_rot
    DW_OP_rot rotates the first three stack entries. The entry at the top of
    the stack becomes the third stack entry, the second entry becomes the top of
    the stack, and the third entry becomes the second entry.

[non-normative] Examples illustrating many of these stack operations are found
in Appendix D.1.2 on page 289.

2.5.4.2 Control Flow Operations

The following operations provide simple control of the flow of a DWARF operation
expression.

1.  DW_OP_nop
    DW_OP_nop is a place holder. It has no effect on the DWARF stack entries.

2.  DW_OP_le, DW_OP_ge, DW_OP_eq, DW_OP_lt, DW_OP_gt, DW_OP_ne
    The six relational operators each:

      * pop the top two stack values, which have the same type, either the same
        base type or the generic type,

      * compare the operands:
        < former second entry >< relational operator >< former top entry >

      * push the constant value 1 onto the stack if the result of the operation
        is true or the constant value 0 if the result of the operation is false.
        The pushed value has the generic type.

    If the operands have the generic type, the comparisons are performed as
    signed operations.

3.  DW_OP_skip
    DW_OP_skip is an unconditional branch. Its single operand is a 2-byte signed
    integer constant. The 2-byte constant is the number of bytes of the DWARF
    expression to skip forward or backward from the current operation, beginning
    after the 2-byte constant.

    If the updated position is at one past the end of the last operation, then
    the operation expression evaluation is complete.

    Otherwise, the DWARF expression is ill-formed if the updated operation
    position is not in the range of the first to last operation inclusive, or
    not at the start of an operation.

4.  DW_OP_bra
    DW_OP_bra is a conditional branch. Its single operand is a 2-byte signed
    integer constant. This operation pops the top of stack. If the value popped
    is not the constant 0, the 2-byte constant operand is the number of bytes of
    the DWARF operation expression to skip forward or backward from the current
    operation, beginning after the 2-byte constant.

    If the updated position is at one past the end of the last operation, then
    the operation expression evaluation is complete.

    Otherwise, the DWARF expression is ill-formed if the updated operation
    position is not in the range of the first to last operation inclusive, or
    not at the start of an operation.

5.  DW_OP_call2, DW_OP_call4, DW_OP_call_ref
    DW_OP_call2, DW_OP_call4, and DW_OP_call_ref perform DWARF procedure calls
    during evaluation of a DWARF operation expression.

    DW_OP_call2 and DW_OP_call4, have one operand that is, respectively, a
    2-byte or 4-byte unsigned offset DR that represents the byte offset of a
    debugging information entry D relative to the beginning of the current
    compilation unit.

    DW_OP_call_ref has one operand that is a 4-byte unsigned value in the 32-bit
    DWARF format, or an 8-byte unsigned value in the 64-bit DWARF format, that
    represents the byte offset DR of a debugging information entry D relative to
    the beginning of the .debug_info section that contains the current
    compilation unit. D may not be in the current compilation unit.

    [non-normative] Operand interpretation of DW_OP_call2, DW_OP_call4, and
    DW_OP_call_ref is exactly like that for DW_FORM_ref2, DW_FORM_ref4, and
    DW_FORM_ref_addr, respectively.

    The call operation is evaluated by:

      * If D has a DW_AT_location attribute that is encoded as a exprloc that
        specifies an operation expression E, then execution of the current
        operation expression continues from the first operation of E. Execution
        continues until one past the last operation of E is reached, at which
        point execution continues with the operation following the call
        operation. The operations of E are evaluated with the same current
        context, except current compilation unit is the one that contains D and
        the stack is the same as that being used by the call operation. After
        the call operation has been evaluated, the stack is therefore as it is
        left by the evaluation of the operations of E. Since E is evaluated on
        the same stack as the call operation, E can use, and/or remove entries
        already on the stack, and can add new entries to the stack.

        [non-normative] Values on the stack at the time of the call may be used
        as parameters by the called expression and values left on the stack by
        the called expression may be used as return values by prior agreement
        between the calling and called expressions.

      * If D has a DW_AT_location attribute that is encoded as a loclist or
        loclistsptr, then the specified location list expression E is evaluated.
        The evaluation of E uses the current context, except the result kind is
        a location description, the compilation unit is the one that contains D,
        and the initial stack is empty. The location description result is
        pushed on the stack.

        > [For further discussion...]
        > This rule avoids having to define how to execute a matched location
        > list entry operation expression on the same stack as the call when
        > there are multiple matches. But it allows the call to obtain the
        > location description for a variable or formal parameter which may use
        > a location list expression.
        >
        > An alternative is to treat the case when D has a DW_AT_location
        > attribute that is encoded as a loclist or loclistsptr, and the
        > specified location list expression E' matches a single location list
        > entry with operation expression E, the same as the exprloc case and
        > evaluate on the same stack.
        >
        > But this is not attractive as if the attribute is for a variable that
        > happens to end with a non-singleton stack, it will not simply put a
        > location description on the stack. Presumably the intent of using
        > DW_OP_call* on a variable or formal parameter debugger information
        > entry is to push just one location description on the stack. That
        > location description may have more than one single location
        > description.
        >
        > The previous rule for exprloc also has the same problem, as normally a
        > variable or formal parameter location expression may leave multiple
        > entries on the stack and only return the top entry.
        >
        > GDB implements DW_OP_call* by always executing E on the same stack. If
        > the location list has multiple matching entries, it simply picks the
        > first one and ignores the rest. This seems fundamentally at odds with
        > the desire to support multiple places for variables.
        >
        > So, it feels like DW_OP_call* should both support pushing a location
        > description on the stack for a variable or formal parameter, and also
        > support being able to execute an operation expression on the same
        > stack. Being able to specify a different operation expression for
        > different program locations seems a desirable feature to retain.
        >
        > A solution to that is to have a distinct DW_AT_proc attribute for the
        > DW_TAG_dwarf_procedure debugging information entry. Then the
        > DW_AT_location attribute expression is always executed separately and
        > pushes a location description (that may have multiple single location
        > descriptions), and the DW_AT_proc attribute expression is always
        > executed on the same stack and can leave anything on the stack.
        >
        > The DW_AT_proc attribute could have the new classes exprproc,
        > loclistproc, and loclistsptrproc to indicate that the expression is
        > executed on the same stack. exprproc is the same encoding as exprloc.
        > loclistproc and loclistsptrproc are the same encoding as their
        > non-proc counterparts, except the DWARF is ill-formed if the location
        > list does not match exactly one location list entry and a default
        > entry is required. These forms indicate explicitly that the matched
        > single operation expression must be executed on the same stack. This
        > is better than ad hoc special rules for loclistproc and
        > loclistsptrproc which are currently clearly defined to always return a
        > location description. The producer then explicitly indicates the
        > intent through the attribute classes.
        >
        > Such a change would be a breaking change for how GDB implements
        > DW_OP_call*. However, are the breaking cases actually occurring in
        > practice? GDB could implement the current approach for DWARF Version
        > 5, and the new semantics for DWARF Version 6 which has been done for
        > some other features.
        >
        > Another option is to limit the execution to be on the same stack only
        > to the evaluation of an expression E that is the value of a
        > DW_AT_location attribute of a DW_TAG_dwarf_procedure debugging
        > information entry. The DWARF would be ill-formed if E is a location
        > list expression that does not match exactly one location list entry.
        > In all other cases the evaluation of an expression E that is the value
        > of a DW_AT_location attribute would evaluate E with the current
        > context, except the result kind is a location description, the
        > compilation unit is the one that contains D, and the initial stack is
        > empty. The location description result is pushed on the stack.

      * If D has a DW_AT_const_value attribute with a value V, then it is as if
        a DW_OP_implicit_value V operation was executed.

        [non-normative] This allows a call operation to be used to compute the
        location description for any variable or formal parameter regardless of
        whether the producer has optimized it to a constant. This is consistent
        with the DW_OP_implicit_pointer operation.

        > [For further discussion...]
        > Alternatively, could deprecate using DW_AT_const_value for
        > DW_TAG_variable and DW_TAG_formal_parameter debugger information
        > entries that are constants and instead use DW_AT_location with an
        > operation expression that results in a location description with one
        > implicit location description. Then this rule would not be required.

      * Otherwise, there is no effect and no changes are made to the stack.

    > [For further discussion...]
    > In DWARF Version 5, if D does not have a DW_AT_location then DW_OP_call*
    > is defined to have no effect. It is unclear that this is the right
    > definition as a producer should be able to rely on using DW_OP_call* to
    > get a location description for any non-DW_TAG_dwarf_procedure debugging
    > information entries. Also, the producer should not be creating DWARF with
    > DW_OP_call* to a DW_TAG_dwarf_procedure that does not have a
    > DW_AT_location attribute. So, should this case be defined as an ill-formed
    > DWARF expression?

    [non-normative] The DW_TAG_dwarf_procedure debugging information entry can
    be used to define DWARF procedures that can be called.

2.5.4.3 Value Operations

This section describes the operations that push values on the stack.

Each value stack entry has a type and a literal value. It can represent a
literal value of any supported base type of the target architecture. The base
type specifies the size, encoding, and endianity of the literal value.

The base type of value stack entries can be the distinguished generic type.

2.5.4.3.1 Literal Operations

The following operations all push a literal value onto the DWARF stack.

Operations other than DW_OP_const_type push a value V with the generic type. If
V is larger than the generic type, then V is truncated to the generic type size
and the low-order bits used.

1.  DW_OP_lit0, DW_OP_lit1, ..., DW_OP_lit31
    DW_OP_lit<N> operations encode an unsigned literal value N from 0 through
    31, inclusive. They push the value N with the generic type.

2.  DW_OP_const1u, DW_OP_const2u, DW_OP_const4u, DW_OP_const8u
    DW_OP_const<N>u operations have a single operand that is a 1, 2, 4, or
    8-byte unsigned integer constant U, respectively. They push the value U with
    the generic type.

3.  DW_OP_const1s, DW_OP_const2s, DW_OP_const4s, DW_OP_const8s
    DW_OP_const<N>s operations have a single operand that is a 1, 2, 4, or
    8-byte signed integer constant S, respectively. They push the value S with
    the generic type.

4.  DW_OP_constu
    DW_OP_constu has a single unsigned LEB128 integer operand N. It pushes the
    value N with the generic type.

5.  DW_OP_consts
    DW_OP_consts has a single signed LEB128 integer operand N. It pushes the
    value N with the generic type.

6.  DW_OP_constx
    DW_OP_constx has a single unsigned LEB128 integer operand that represents a
    zero-based index into the .debug_addr section relative to the value of the
    DW_AT_addr_base attribute of the associated compilation unit. The value N in
    the .debug_addr section has the size of the generic type. It pushes the
    value N with the generic type.

    [non-normative] The DW_OP_constx operation is provided for constants that
    require link-time relocation but should not be interpreted by the consumer
    as a relocatable address (for example, offsets to thread-local storage).

7.  DW_OP_const_type
    DW_OP_const_type has three operands. The first is an unsigned LEB128 integer
    DR that represents the byte offset of a debugging information entry D
    relative to the beginning of the current compilation unit, that provides the
    type T of the constant value. The second is a 1-byte unsigned integral
    constant S. The third is a block of bytes B, with a length equal to S.

    TS is the bit size of the type T. The least significant TS bits of B are
    interpreted as a value V of the type D. It pushes the value V with the type
    D.

    The DWARF is ill-formed if D is not a DW_TAG_base_type debugging information
    entry in the current compilation unit, or if TS divided by 8 (the byte size)
    and rounded up to a whole number is not equal to S.

    [non-normative] While the size of the byte block B can be inferred from the
    type D definition, it is encoded explicitly into the operation so that the
    operation can be parsed easily without reference to the .debug_info section.

8.  DW_OP_push_lane
    DW_OP_push_lane pushes the current lane as a value with the generic type.

    [non-normative] For source languages that are implemented using a SIMD/SIMT
    execution model, this is the zero-based lane number upon which the user is
    focused. This may correspond to a SIMD concurrent loop iteration execution
    and/or SIMT source language thread of execution.

    The value must be greater than or equal to 0 and less than the value of the
    DW_AT_lanes attribute, otherwise the DWARF expression is ill-formed. See
    Section 3.3.5 "Low-Level Information".

2.5.4.3.2 Arithmetic and Logical Operations

The following provide arithmetic and logical operations. Operands of an
operation with two operands must have the same type, either the same base type
or the generic type. The result of the operation which is pushed back has the
same type as the type of the operand(s).

If the type of the operands is the generic type, except as otherwise specified,
the arithmetic operations perform addressing arithmetic, that is, unsigned
arithmetic that is performed modulo one plus the largest representable address.

Operations other than DW_OP_abs, DW_OP_div, DW_OP_minus, DW_OP_mul, DW_OP_neg
and DW_OP_plus require integral types of the operand (either integral base type
or the generic type). Operations do not cause an exception on overflow.

1.  DW_OP_abs
    The DW_OP_abs operation pops the top stack entry, interprets it as a signed
    value and pushes its absolute value. If the absolute value cannot be
    represented, the result is undefined.

2.  DW_OP_and
    The DW_OP_and operation pops the top two stack values, performs a bitwise
    and operation on the two, and pushes the result.

3.  DW_OP_div
    The DW_OP_div operation pops the top two stack values, divides the former
    second entry by the former top of the stack using signed division, and
    pushes the result.

4.  DW_OP_minus
    The DW_OP_minus operation pops the top two stack values, subtracts the
    former top of the stack from the former second entry, and pushes the result.

5.  DW_OP_mod
    The DW_OP_mod operation pops the top two stack values and pushes the result
    of the calculation: former second stack entry modulo the former top of the
    stack.

6.  DW_OP_mul
    The DW_OP_mul operation pops the top two stack entries, multiplies them
    together, and pushes the result.

7.  DW_OP_neg
    The DW_OP_neg operation pops the top stack entry, interprets it as a signed
    value and pushes its negation. If the negation cannot be represented, the
    result is undefined.

8.  DW_OP_not
    The DW_OP_not operation pops the top stack entry, and pushes its bitwise
    complement.

9.  DW_OP_or
    The DW_OP_or operation pops the top two stack entries, performs a bitwise or
    operation on the two, and pushes the result.

10. DW_OP_plus
    The DW_OP_plus operation pops the top two stack entries, adds them together,
    and pushes the result.

11. DW_OP_plus_uconst
    The DW_OP_plus_uconst operation pops the top stack entry, adds it to the
    unsigned LEB128 constant operand interpreted as the same type as the operand
    popped from the top of the stack and pushes the result.

    [non-normative] This operation is supplied specifically to be able to encode
    more field offsets in two bytes than can be done with “DW_OP_lit<n>
    DW_OP_plus.”

12. DW_OP_shl
    The DW_OP_shl operation pops the top two stack entries, shifts the former
    second entry left (filling with zero bits) by the number of bits specified
    by the former top of the stack, and pushes the result.

13. DW_OP_shr
    The DW_OP_shr operation pops the top two stack entries, shifts the former
    second entry right logically (filling with zero bits) by the number of bits
    specified by the former top of the stack, and pushes the result.

14. DW_OP_shra
    The DW_OP_shra operation pops the top two stack entries, shifts the former
    second entry right arithmetically (divide the magnitude by 2, keep the same
    sign for the result) by the number of bits specified by the former top of
    the stack, and pushes the result.

15. DW_OP_xor
    The DW_OP_xor operation pops the top two stack entries, performs a bitwise
    exclusive-or operation on the two, and pushes the result.

2.5.4.3.3 Type Conversion Operations

The following operations provides for explicit type conversion.

1.  DW_OP_convert
    The DW_OP_convert operation pops the top stack entry, converts it to a
    different type, then pushes the result. It takes one operand, which is an
    unsigned LEB128 integer that represents the offset of a debugging
    information entry in the current compilation unit, or value 0 which
    represents the generic type. If the operand is non-zero, the referenced
    entry must be a DW_TAG_base_type entry that provides the type to which the
    value is converted.

2.  DW_OP_reinterpret
    The DW_OP_reinterpret operation pops the top stack entry, reinterprets the
    bits in its value as a value of a different type, then pushes the result. It
    takes one operand, which is an unsigned LEB128 integer that represents the
    offset of a debugging information entry in the current compilation unit, or
    value 0 which represents the generic type. If the operand is non-zero, the
    referenced entry must be a DW_TAG_base_type entry that provides the type to
    which the value is converted. The type of the operand and result type must
    have the same size in bits.

2.5.4.3.4 Special Value Operations

There are these special value operations currently defined:

1.  DW_OP_regval_type
    DW_OP_regval_type has two operands. The first is an unsigned LEB128 integer
    that represents a register number R. The second is an unsigned LEB128
    integer DR that represents the byte offset of a debugging information entry
    D relative to the beginning of the current compilation unit, that provides
    the type T of the register value.

    The operation is equivalent to performing DW_OP_regx R; DW_OP_deref_type DR.

    > [For further discussion...]
    > Should DWARF allow the type T to be a larger size than the size of the
    > register R? Restricting a larger bit size avoids any issue of conversion
    > as the, possibly truncated, bit contents of the register is simply
    > interpreted as a value of T. If a conversion is wanted it can be done
    > explicitly using a DW_OP_convert operation.
    >
    > GDB has a per register hook that allows a target specific conversion on a
    > register by register basis. It defaults to truncation of bigger registers.
    > Removing use of the target hook does not cause any test failures in common
    > architectures. If the compiler for a target architecture did want some
    > form of conversion, including a larger result type, it could always
    > explicitly use the DW_OP_convert operation.
    >
    > If T is a larger type than the register size, then the default GDB
    > register hook reads bytes from the next register (or reads out of bounds
    > for the last register!). Removing use of the target hook does not cause
    > any test failures in common architectures (except an illegal hand written
    > assembly test). If a target architecture requires this behavior, these
    > extensions allow a composite location description to be used to combine
    > multiple registers.

2.  DW_OP_deref
    S is the bit size of the generic type divided by 8 (the byte size) and
    rounded up to a whole number. DR is the offset of a hypothetical debug
    information entry D in the current compilation unit for a base type of the
    generic type.

    The operation is equivalent to performing DW_OP_deref_type S, DR.

3.  DW_OP_deref_size
    DW_OP_deref_size has a single 1-byte unsigned integral constant that
    represents a byte result size S.

    TS is the smaller of the generic type bit size and S scaled by 8 (the byte
    size). If TS is smaller than the generic type bit size then T is an unsigned
    integral type of bit size TS, otherwise T is the generic type. DR is the
    offset of a hypothetical debug information entry D in the current
    compilation unit for a base type T.

    > [For further discussion...]
    > Truncating the value when S is larger than the generic type matches what
    > GDB does. This allows the generic type size to not be an integral byte
    > size. It does allow S to be arbitrarily large. Should S be restricted to
    > the size of the generic type rounded up to a multiple of 8?

    The operation is equivalent to performing DW_OP_deref_type S, DR, except if
    T is not the generic type, the value V pushed is zero-extended to the
    generic type bit size and its type changed to the generic type.

4.  DW_OP_deref_type
    DW_OP_deref_type has two operands. The first is a 1-byte unsigned integral
    constant S. The second is an unsigned LEB128 integer DR that represents the
    byte offset of a debugging information entry D relative to the beginning of
    the current compilation unit, that provides the type T of the result value.

    TS is the bit size of the type T.

    [non-normative] While the size of the pushed value V can be inferred from
    the type T, it is encoded explicitly as the operand S so that the operation
    can be parsed easily without reference to the .debug_info section.

    > [For further discussion...]
    > It is unclear why the operand S is needed. Unlike DW_OP_const_type, the
    > size is not needed for parsing. Any evaluation needs to get the base type
    > T to push with the value to know its encoding and bit size.

    It pops one stack entry that must be a location description L.

    A value V of TS bits is retrieved from the location storage LS specified by
    one of the single location descriptions SL of L.

    [non-normative] If L, or the location description of any composite location
    description part that is a subcomponent of L, has more than one single
    location description, then any one of them can be selected as they are
    required to all have the same value. For any single location description SL,
    bits are retrieved from the associated storage location starting at the bit
    offset specified by SL. For a composite location description, the retrieved
    bits are the concatenation of the N bits from each composite location part
    PL, where N is limited to the size of PL.

    V is pushed on the stack with the type T.

    > [For further discussion...]
    > This definition makes it an evaluation error if L is a register location
    > description that has less than TS bits remaining in the register storage.
    > Particularly since these extensions extend location descriptions to have a
    > bit offset, it would be odd to define this as performing sign extension
    > based on the type, or be target architecture dependent, as the number of
    > remaining bits could be any number. This matches the GDB implementation
    > for DW_OP_deref_type.
    >
    > These extensions define DW_OP_*breg* in terms of DW_OP_regval_type.
    > DW_OP_regval_type is defined in terms of DW_OP_regx, which uses a 0 bit
    > offset, and DW_OP_deref_type. Therefore, it requires the register size to
    > be greater or equal to the address size of the address space. This matches
    > the GDB implementation for DW_OP_*breg*.

    The DWARF is ill-formed if D is not in the current compilation unit, D is
    not a DW_TAG_base_type debugging information entry, or if TS divided by 8
    (the byte size) and rounded up to a whole number is not equal to S.

    > [For further discussion...]
    > This definition allows the base type to be a bit size since there seems no
    > reason to restrict it.

    It is an evaluation error if any bit of the value is retrieved from the
    undefined location storage or the offset of any bit exceeds the size of the
    location storage LS specified by any single location description SL of L.

    See 2.5.x.x Implicit Location Description Operations for special rules
    concerning implicit location descriptions created by the
    DW_OP_implicit_pointer and DW_OP_aspace_implicit_pointer operations.

5.  DW_OP_xderef
    DW_OP_xderef pops two stack entries. The first must be an integral type
    value that represents an address A. The second must be an integral type
    value that represents a target architecture specific address space
    identifier AS.

    The operation is equivalent to performing DW_OP_swap;
    DW_OP_form_aspace_address; DW_OP_deref. The value V retrieved is left on the
    stack with the generic type.

6.  DW_OP_xderef_size
    DW_OP_xderef_size has a single 1-byte unsigned integral constant that
    represents a byte result size S.

    It pops two stack entries. The first must be an integral type value that
    represents an address A. The second must be an integral type value that
    represents a target architecture specific address space identifier AS.

    The operation is equivalent to performing DW_OP_swap;
    DW_OP_form_aspace_address; DW_OP_deref_size S. The zero-extended value V
    retrieved is left on the stack with the generic type.

7.  DW_OP_xderef_type
    DW_OP_xderef_type has two operands. The first is a 1-byte unsigned integral
    constant S. The second operand is an unsigned LEB128 integer DR that
    represents the byte offset of a debugging information entry D relative to
    the beginning of the current compilation unit, that provides the type T of
    the result value.

    It pops two stack entries. The first must be an integral type value that
    represents an address A. The second must be an integral type value that
    represents a target architecture specific address space identifier AS.

    The operation is equivalent to performing DW_OP_swap;
    DW_OP_form_aspace_address; DW_OP_deref_type S DR. The value V retrieved is
    left on the stack with the type T.

8.  DW_OP_entry_value
    DW_OP_entry_value pushes the value of an expression that is evaluated in the
    context of the calling frame.

    [non-normative] It may be used to determine the value of arguments on entry
    to the current call frame provided they are not clobbered.

    It has two operands. The first is an unsigned LEB128 integer S. The second
    is a block of bytes, with a length equal S, interpreted as a DWARF operation
    expression E.

    E is evaluated with the current context, with the following modifications: the result kind is
    unspecified, the call frame is the one that called the current frame, the
    program location is the call site in the calling frame, the object is
    unspecified, and the initial stack is empty. The calling frame information
    is obtained by virtually unwinding the current call frame using the call
    frame information (see 6.4 Call Frame Information).

    If the result of E is a location description L (see 2.5.x.x Register
    Location Description Operations), and the last operation executed by E is a
    DW_OP_reg* for register R with a target architecture specific base type of
    T, then the contents of the register are retrieved as if a DW_OP_deref_type
    DR operation was performed where DR is the offset of a hypothetical debug
    information entry in the current compilation unit for T. The resulting value
    V s pushed on the stack.

    [non-normative] Using DW_OP_reg* provides a more compact form for the case
    where the value was in a register on entry to the subprogram.

    > [For further discussion...]
    > It is unclear how this provides a more compact expression, as
    > DW_OP_regval_type could be used which is marginally larger.

    If the result of E is a value V, then V is pushed on the stack.

    Otherwise, the DWARF expression is ill-formed.

2.5.4.4 Location Description Operations

This section describes the operations that push location descriptions on the
stack.

2.5.4.4.1 General Location Description Operations

1.  DW_OP_offset
    DW_OP_offset pops two stack entries. The first must be an integral type
    value that represents a byte displacement B. The second must be a location
    description L.

    It adds the value of B scaled by 8 (the byte size) to the bit offset of each
    single location description SL of L, and pushes the updated L.

    It is an evaluation error if the updated bit offset of any SL is less than 0
    or greater than or equal to the size of the location storage specified by
    SL.

2.  DW_OP_offset_uconst
    DW_OP_offset_uconst has a single unsigned LEB128 integer operand that
    represents a byte displacement B.

    The operation is equivalent to performing DW_OP_constu B; DW_OP_offset.

    [non-normative] This operation is supplied specifically to be able to
    encode more field displacements in two bytes than can be done with
    DW_OP_lit*; DW_OP_offset.

    > [For further discussion...]
    > Should DW_OP_offset_uconst be named DW_OP_offset_uconst to match
    > DW_OP_plus_uconst, or DW_OP_offset_constu to match DW_OP_constu?

3.  DW_OP_bit_offset
    DW_OP_bit_offset pops two stack entries. The first must be an integral type
    value that represents a bit displacement B. The second must be a location
    description L.

    It adds the value of B to the bit offset of each single location
    description SL of L, and pushes the updated L.

    It is an evaluation error if the updated bit offset of any SL is less than
    0 or greater than or equal to the size of the location storage specified by
    SL.

4.  DW_OP_push_object_address
    DW_OP_push_object_address pushes the location description L of the current
    object.

    [non-normative] This object may correspond to an independent variable that
    is part of a user presented expression that is being evaluated. The object
    location description may be determined from the variable’s own debugging
    information entry or it may be a component of an array, structure, or class
    whose address has been dynamically determined by an earlier step during user
    expression evaluation.

    [non-normative] This operation provides explicit functionality (especially
    for arrays involving descriptors) that is analogous to the implicit push of
    the base location description of a structure prior to evaluation of a
    DW_AT_data_member_location to access a data member of a structure.

    > [For further discussion...]
    > This operation could be removed and the object location description
    > specified as the initial stack as for DW_AT_data_member_location.
    >
    > Or this operation could be used instead of needing to specify an initial
    > stack. The latter approach is more composable as access to the object may
    > be needed at any point of the expression, and passing it as the initial
    > stack requires the entire expression to be aware where on the stack it is.
    > If this were done, DW_AT_use_location would require a
    > DW_OP_push_object2_address operation for the second object.
    >
    > Or a more general way to pass an arbitrary number of arguments in and an
    > operation to get the Nth one such as DW_OP_arg N. A vector of arguments
    > would then be passed in the expression context rather than an initial
    > stack. This could also resolve the issues with DW_OP_call* by allowing a
    > specific number of arguments passed in and returned to be specified. The
    > DW_OP_call* operation could then always execute on a separate stack: the
    > number of arguments would be specified in a new call operation and taken
    > from the callers stack, and similarly the number of return results
    > specified and copied from the called stack back to the callee stack when
    > the called expression was complete.
    >
    > The only attribute that specifies a current object is DW_AT_data_location
    > so the non-normative text seems to overstate how this is being used. Or
    > are there other attributes that need to state they pass an object?

5.  DW_OP_call_frame_entry_reg
    DW_OP_call_frame_entry_reg has a single unsigned LEB128 integer operand that
    represents a target architecture register number R.

    It pushes a location description L that holds the value of register R on
    entry to the current subprogram as defined by the call frame information
    (see Section 6.4 "Call Frame Information").

    [non-normative] If there is no call frame information defined, then the
    default rules for the target architecture are used. If the register rule is
    <i>undefined</i>, then the undefined location description is pushed. If the
    register rule is <i>same value</i>, then a register location description for
    R is pushed.

2.5.4.4.2 Undefined Location Description Operations

[non-normative] The undefined location storage represents a piece or all of an
object that is present in the source but not in the object code (perhaps due to
optimization). Neither reading nor writing to the undefined location storage is
meaningful.

An undefined location description specifies the undefined location storage.
There is no concept of the size of the undefined location storage, nor of a bit
offset for an undefined location description. The DW_OP_*offset operations
leave an undefined location description unchanged. The DW_OP_*piece operations
can explicitly or implicitly specify an undefined location description,
allowing any size and offset to be specified, and results in a part with all
undefined bits.

1.  DW_OP_undefined
    DW_OP_undefined pushes a location description L that comprises one
    undefined location description SL.

2.5.4.4.3 Memory Location Description Operations

Each of the target architecture specific address spaces has a corresponding
memory location storage that denotes the linear addressable memory of that
address space. The size of each memory location storage corresponds to the range
of the addresses in the corresponding address space.

[non-normative] It is target architecture defined how address space location
storage maps to target architecture physical memory. For example, they may be
independent memory, or more than one location storage may alias the same
physical memory possibly at different offsets and with different interleaving.
The mapping may also be dictated by the source language address classes.

A memory location description specifies a memory location storage. The bit
offset corresponds to a bit position within a byte of the memory. Bits accessed
using a memory location description, access the corresponding target
architecture memory starting at the bit position within the byte specified by
the bit offset.

A memory location description that has a bit offset that is a multiple of 8 (the
byte size) is defined to be a byte address memory location description. It has a
memory byte address A that is equal to the bit offset divided by 8.

A memory location description that does not have a bit offset that is a multiple
of 8 (the byte size) is defined to be a bit field memory location description.
It has a bit position B equal to the bit offset modulo 8, and a memory byte
address A equal to the bit offset minus B that is then divided by 8.

The address space AS of a memory location description is defined to be the
address space that corresponds to the memory location storage associated with
the memory location description.

A location description that is comprised of one byte address memory location
description SL is defined to be a memory byte address location description. It
has a byte address equal to A and an address space equal to AS of the
corresponding SL.

DW_ASPACE_none is defined as the target architecture default address space. See
2.13 Address Spaces.

If a stack entry is required to be a location description, but it is a value V
with the generic type, then it is implicitly converted to a location description
L with one memory location description SL. SL specifies the memory location
storage that corresponds to the target architecture default address space with a
bit offset equal to V scaled by 8 (the byte size).

> [For further discussion...]
> If it is wanted to allow any integral type value to be implicitly converted to
> a memory location description in the target architecture default address
> space:
>
>   If a stack entry is required to be a location description, but is a value V
>   with an integral type, then it is implicitly converted to a location
>   description L with a one memory location description SL. If the type size of
>   V is less than the generic type size, then the value V is zero extended to
>   the size of the generic type. The least significant generic type size bits
>   are treated as an unsigned value to be used as an address A. SL specifies
>   memory location storage corresponding to the target architecture default
>   address space with a bit offset equal to A scaled by 8 (the byte size).
>
> The implicit conversion could also be defined as target architecture specific.
> For example, GDB checks if V is an integral type. If it is not it gives an
> error. Otherwise, GDB zero-extends V to 64 bits. If the GDB target defines a
> hook function, then it is called. The target specific hook function can modify
> the 64-bit value, possibly sign extending based on the original value type.
> Finally, GDB treats the 64-bit value V as a memory location address.

If a stack entry is required to be a location description, but it is an implicit
pointer value IPV with the target architecture default address space, then it is
implicitly converted to a location description with one single location
description specified by IPV. See 2.5.4.4.5 Implicit Location Description
Operations.

> [For further discussion...]
> Is this rule required for DWARF Version 5 backwards compatibility? If not, it
> can be eliminated, and the producer can use DW_OP_form_aspace_address.

If a stack entry is required to be a value, but it is a location description L
with one memory location description SL in the target architecture default
address space with a bit offset B that is a multiple of 8, then it is implicitly
converted to a value equal to B divided by 8 (the byte size) with the generic
type.

1.  DW_OP_addr
    DW_OP_addr has a single byte constant value operand, which has the size of
    the generic type, that represents an address A.

    It pushes a location description L with one memory location description SL
    on the stack. SL specifies the memory location storage corresponding to the
    target architecture default address space with a bit offset equal to A
    scaled by 8 (the byte size).

    [non-normative] If the DWARF is part of a code object, then A may need to be
    relocated. For example, in the ELF code object format, A must be adjusted by
    the difference between the ELF segment virtual address and the virtual
    address at which the segment is loaded.

2.  DW_OP_addrx
    DW_OP_addrx has a single unsigned LEB128 integer operand that represents a
    zero-based index into the .debug_addr section relative to the value of the
    DW_AT_addr_base attribute of the associated compilation unit. The address
    value A in the .debug_addr section has the size of the generic type.

    It pushes a location description L with one memory location description SL
    on the stack. SL specifies the memory location storage corresponding to the
    target architecture default address space with a bit offset equal to A
    scaled by 8 (the byte size).

    [non-normative] If the DWARF is part of a code object, then A may need to be
    relocated. For example, in the ELF code object format, A must be adjusted by
    the difference between the ELF segment virtual address and the virtual
    address at which the segment is loaded.

3.  DW_OP_form_aspace_address
    DW_OP_form_aspace_address pops top two stack entries. The first must be an
    integral type value that represents a target architecture specific address
    space identifier AS. The second must be an integral type value that
    represents an address A.

    The address size S is defined as the address bit size of the target
    architecture specific address space that corresponds to AS.

    A is adjusted to S bits by zero extending if necessary, and then treating
    the least significant S bits as an unsigned value A'.

    It pushes a location description L with one memory location description SL
    on the stack. SL specifies the memory location storage LS that corresponds
    to AS with a bit offset equal to A' scaled by 8 (the byte size).

    If AS is an address space that is specific to context elements, then LS
    corresponds to the location storage associated with the current context.

    [non-normative] For example, if AS is for per thread storage then LS is the
    location storage for the current thread. For languages that are implemented
    using a SIMT execution model, then if AS is for per source language thread
    of execution storage then LS is the location storage for the SIMT thread
    associated with the current lane of the current thread. Therefore, if L is
    accessed by an operation, the location storage selected when the location
    description was created is accessed, and not the location storage associated
    with the current context of the access operation.

    The DWARF expression is ill-formed if AS is not one of the values defined by
    the target architecture specific DW_ASPACE_* values.

    See Section 2.5.4.4.5 "Implicit Location Description Operations" for special
    rules concerning implicit pointer values produced by dereferencing implicit
    location descriptions created by the DW_OP_implicit_pointer and
    DW_OP_aspace_implicit_pointer operations.

4.  DW_OP_form_tls_address
    DW_OP_form_tls_address pops one stack entry that must be an integral type
    value and treats it as a thread-local storage address TA.

    It pushes a location description L with one memory location description SL
    on the stack. SL is the target architecture specific memory location
    description that corresponds to the thread-local storage address TA.

    The meaning of the thread-local storage address TA is defined by the
    run-time environment. If the run-time environment supports multiple
    thread-local storage blocks for a single thread, then the block
    corresponding to the executable or shared library containing this DWARF
    expression is used.

    [non-normative] Some implementations of C, C++, Fortran, and other
    languages, support a thread-local storage class. Variables with this storage
    class have distinct values and addresses in distinct threads, much as
    automatic variables have distinct values and addresses in each function
    invocation. Typically, there is a single block of storage containing all
    thread-local variables declared in the main executable, and a separate block
    for the variables declared in each shared library. Each thread-local
    variable can then be accessed in its block using an identifier. This
    identifier is typically an offset into the block and pushed onto the DWARF
    stack by one of the DW_OP_const<n><x> operations prior to the
    DW_OP_form_tls_address operation. Computing the address of the appropriate
    block can be complex (in some cases, the compiler emits a function call to
    do it), and difficult to describe using ordinary DWARF location
    descriptions. Instead of forcing complex thread-local storage calculations
    into the DWARF expressions, the DW_OP_form_tls_address allows the consumer
    to perform the computation based on the run-time environment.
 
5.  DW_OP_call_frame_cfa
    DW_OP_call_frame_cfa pushes the location description L of the Canonical
    Frame Address (CFA) of the current subprogram, obtained from the call frame
    information on the stack. See Section 6.4 Call Frame Information.

    [non-normative] Although the value of the DW_AT_frame_base attribute of the
    debugger information entry corresponding to the current subprogram can be
    computed using a location list expression, in some cases this would require
    an extensive location list because the values of the registers used in
    computing the CFA change during a subprogram execution. If the call frame
    information is present, then it already encodes such changes, and it is
    space efficient to reference that using the DW_OP_call_frame_cfa operation.

6.  DW_OP_fbreg
    DW_OP_fbreg has a single signed LEB128 integer operand that represents a
    byte displacement B.

    The location description L for the <i>frame base</i> of the current
    subprogram is obtained from the DW_AT_frame_base attribute of the debugger
    information entry corresponding to the current subprogram as described in
    3.3.5 Low-Level Information.

    The location description L is updated as if the DW_OP_offset_uconst B
    operation was applied. The updated L is pushed on the stack.

7.  DW_OP_breg0, DW_OP_breg1, ..., DW_OP_breg31
    The DW_OP_breg<N> operations encode the numbers of up to 32 registers,
    numbered from 0 through 31, inclusive. The register number R corresponds to
    the N in the operation name.

    They have a single signed LEB128 integer operand that represents a byte
    displacement B.

    The address space identifier AS is defined as the one corresponding to the
    target architecture specific default address space.

    The address size S is defined as the address bit size of the target
    architecture specific address space corresponding to AS.

    The contents of the register specified by R are retrieved as if a
    DW_OP_regval_type R, DR operation was performed where DR is the offset of a
    hypothetical debug information entry in the current compilation unit for an
    unsigned integral base type of size S bits. B is added and the least
    significant S bits are treated as an unsigned value to be used as an address
    A.

    They push a location description L comprising one memory location
    description LS on the stack. LS specifies the memory location storage that
    corresponds to AS with a bit offset equal to A scaled by 8 (the byte size).

8.  DW_OP_bregx
    DW_OP_bregx has two operands. The first is an unsigned LEB128 integer that
    represents a register number R. The second is a signed LEB128 integer that
    represents a byte displacement B.

    The action is the same as for DW_OP_breg<N>, except that R is used as the
    register number and B is used as the byte displacement.

9.  DW_OP_aspace_bregx
    DW_OP_aspace_bregx has two operands. The first is an unsigned
    LEB128 integer that represents a register number R. The second is a signed
    LEB128 integer that represents a byte displacement B. It pops one stack
    entry that is required to be an integral type value that represents a target
    architecture specific address space identifier AS.

    The action is the same as for DW_OP_breg<N>, except that R is used as
    the register number, B is used as the byte displacement, and AS is used as
    the address space identifier.

    The DWARF expression is ill-formed if AS is not one of the values defined by
    the target architecture specific DW_ASPACE_* values.

    > [For further discussion...]
    > Could also consider adding DW_OP_aspace_breg0, DW_OP_aspace_breg1, ...,
    > DW_OP_aspace_bref31 which would save encoding size.

2.5.4.4.4 Register Location Description Operations

There is a register location storage that corresponds to each of the target
architecture registers. The size of each register location storage corresponds
to the size of the corresponding target architecture register.

A register location description specifies a register location storage. The bit
offset corresponds to a bit position within the register. Bits accessed using a
register location description access the corresponding target architecture
register starting at the specified bit offset.

1.  DW_OP_reg0, DW_OP_reg1, ..., DW_OP_reg31
    The DW_OP_reg<n> operations encode the numbers of up to 32 registers,
    numbered from 0 through 31, inclusive. The target architecture register
    number R corresponds to the N in the operation name.

    The operation is equivalent to performing DW_OP_regx R.

2.  DW_OP_regx
    DW_OP_regx has a single unsigned LEB128 integer operand that represents a
    target architecture register number R.

    If the current call frame is the top call frame, it pushes a location
    description L that specifies one register location description SL on the
    stack. SL specifies the register location storage that corresponds to R with
    a bit offset of 0 for the current thread.

    If the current call frame is not the top call frame, call frame information
    (see 6.4 Call Frame Information) is used to determine the location
    description that holds the register for the current call frame and current
    program location of the current thread. The resulting location description L
    is pushed.

    [non-normative] Note that if call frame information is used, the resulting
    location description may be register, memory, or undefined.

    [non-normative] An implementation may evaluate the call frame information
    immediately, or may defer evaluation until L is accessed by an operation. If
    evaluation is deferred, R and the current context can be recorded in L. When
    accessed, the recorded context is used to evaluate the call frame
    information, not the current context of the access operation.

[non-normative] These operations obtain a register location. To fetch the
contents of a register, it is necessary to use DW_OP_regval_type, use one of the
DW_OP_breg* register-based addressing operations, or use DW_OP_deref* on a
register location description.

2.5.4.4.5 Implicit Location Description Operations

Implicit location storage represents a piece or all of an object which has no
actual location in the program but whose contents are nonetheless known, either
as a constant or can be computed from other locations and values in the program.

An implicit location description specifies an implicit location storage. The bit
offset corresponds to a bit position within the implicit location storage. Bits
accessed using an implicit location description, access the corresponding
implicit storage value starting at the bit offset.

1.  DW_OP_implicit_value
    DW_OP_implicit_value has two operands. The first is an unsigned LEB128
    integer that represents a byte size S. The second is a block of bytes with a
    length equal to S treated as a literal value V.

    An implicit location storage LS is created with the literal value V and a
    size of S.

    It pushes location description L with one implicit location description SL
    on the stack. SL specifies LS with a bit offset of 0.

2.  DW_OP_stack_value
    DW_OP_stack_value pops one stack entry that must be a value V.

    An implicit location storage LS is created with the literal value V using
    the size, encoding, and endianity specified by V’s base type.

    It pushes a location description L with one implicit location description SL
    on the stack. SL specifies LS with a bit offset of 0.

    [non-normative] The DW_OP_stack_value operation specifies that the object
    does not exist in memory, but its value is nonetheless known. In this form,
    the location description specifies the actual value of the object, rather
    than specifying the memory or register storage that holds the value.

    See DW_OP_implicit_pointer (following) for special rules concerning implicit
    pointer values produced by dereferencing implicit location descriptions
    created by the DW_OP_implicit_pointer and DW_OP_aspace_implicit_pointer
    operations.

    Note: Since location descriptions are allowed on the stack, the
    DW_OP_stack_value operation no longer terminates the DWARF operation
    expression execution as in DWARF Version 5.

3.  DW_OP_implicit_pointer
    [non-normative] An optimizing compiler may eliminate a pointer, while still
    retaining the value that the pointer addressed. DW_OP_implicit_pointer
    allows a producer to describe this value.

    [non-normative] DW_OP_implicit_pointer specifies an object is a pointer to
    the target architecture default address space that cannot be represented as
    a real pointer, even though the value it would point to can be described. In
    this form, the location description specifies a debugging information entry
    that represents the actual location description of the object to which the
    pointer would point. Thus, a consumer of the debug information would be able
    to access the dereferenced pointer, even when it cannot access the pointer
    itself.

    DW_OP_implicit_pointer has two operands. The first operand is a 4-byte
    unsigned value in the 32-bit DWARF format, or an 8-byte unsigned value in
    the 64-bit DWARF format, that represents the byte offset DR of a debugging
    information entry D relative to the beginning of the .debug_info section
    that contains the current compilation unit. The second operand is a signed
    LEB128 integer that represents a byte displacement B.

    [non-normative] Note that D might not be in the current compilation unit.

    [non-normative] The first operand interpretation is exactly like that for
    DW_FORM_ref_addr.

    The address space identifier AS is defined as the one corresponding to the
    target architecture specific default address space.

    The address size S is defined as the address bit size of the target
    architecture specific address space corresponding to AS.

    An implicit location storage LS is created with the debugging information
    entry D, address space AS, and size of S.

    It pushes a location description L that comprises one implicit location
    description SL on the stack. SL specifies LS with a bit offset of 0.

    It is an evaluation error if a DW_OP_deref* operation pops a location
    description L’, and retrieves S bits, such that any retrieved bits come from
    an implicit location storage that is the same as LS, unless both the
    following conditions are met:

    1.  All retrieved bits come from an implicit location description that
        refers to an implicit location storage that is the same as LS.

        [non-normative] Note that all bits do not have to come from the same
        implicit location description, as L’ may involve composite location
        descriptions.

    2.  The bits come from consecutive ascending offsets within their respective
        implicit location storage.

    [non-normative] These rules are equivalent to retrieving the complete
    contents of LS.

    If both the above conditions are met, then the value V pushed by the
    DW_OP_deref* operation is an implicit pointer value IPV with a target
    architecture specific address space of AS, a debugging information entry of
    D, and a base type of T. If AS is the target architecture default address
    space, then T is the generic type. Otherwise, T is a target architecture
    specific integral type with a bit size equal to S.

    If IPV is either implicitly converted to a location description (only done
    if AS is the target architecture default address space) or used by
    DW_OP_form_aspace_address (only done if the address space popped by
    DW_OP_form_aspace_address is AS), then the resulting location description RL
    is:

      * If D has a DW_AT_location attribute, the DWARF expression E from the
        DW_AT_location attribute is evaluated with the current context, except
        that the result kind is a location description, the compilation unit is
        the one that contains D, the object is unspecified, and the initial
        stack is empty. RL is the expression result.

        [non-normative] Note that E is evaluated with the context of the
        expression accessing IPV, and not the context of the expression that
        contained the DW_OP_implicit_pointer or DW_OP_aspace_implicit_pointer
        operation that created L.

      * If D has a DW_AT_const_value attribute, then an implicit location
        storage RLS is created from the DW_AT_const_value attribute’s value with
        a size matching the size of the DW_AT_const_value attribute’s value. RL
        comprises one implicit location description SRL. SRL specifies RLS with
        a bit offset of 0.

        > [For further discussion...]
        > If using DW_AT_const_value for variables and formal parameters is
        > deprecated and instead DW_AT_location is used with an implicit
        > location description, then this rule would not be required.

      * Otherwise, it is an evaluation error.

    The bit offset of RL is updated as if the DW_OP_offset_uconst B operation
    was applied.

    If a DW_OP_stack_value operation pops a value that is the same as IPV, then
    it pushes a location description that is the same as L.

    It is an evaluation error if LS or IPV is accessed in any other manner.

    [non-normative] The restrictions on how an implicit pointer location
    description created by DW_OP_implicit_pointer and
    DW_OP_aspace_implicit_pointer can be used are to simplify the DWARF
    consumer. Similarly, for an implicit pointer value created by DW_OP_deref*
    and DW_OP_stack_value.

4.  DW_OP_aspace_implicit_pointer
    DW_OP_aspace_implicit_pointer has two operands that are the same as for
    DW_OP_implicit_pointer.

    It pops one stack entry that must be an integral type value that represents
    a target architecture specific address space identifier AS.

    The location description L that is pushed on the stack is the same as for
    DW_OP_implicit_pointer, except that the address space identifier used is AS.

    The DWARF expression is ill-formed if AS is not one of the values defined by
    the target architecture specific DW_ASPACE_* values.
 
[non-normative] Typically a DW_OP_implicit_pointer or
DW_OP_aspace_implicit_pointer operation is used in a DWARF expression E1 of a
DW_TAG_variable or DW_TAG_formal_parameter debugging information entry D1's
DW_AT_location attribute. The debugging information entry referenced by the
DW_OP_implicit_pointer or DW_OP_aspace_implicit_pointer operations is typically
itself a DW_TAG_variable or DW_TAG_formal_parameter debugging information entry
D2 whose DW_AT_location attribute gives a second DWARF expression E2.

[non-normative] D1 and E1 are describing the location of a pointer type object.
D2 and E2 are describing the location of the object pointed to by that pointer
object.

[non-normative] However, D2 may be any debugging information entry that contains
a DW_AT_location or DW_AT_const_value attribute (for example,
DW_TAG_dwarf_procedure). By using E2, a consumer can reconstruct the value of
the object when asked to dereference the pointer described by E1 which contains
the DW_OP_implicit_pointer or DW_OP_aspace_implicit_pointer operation.

2.5.4.4.6 Composite Location Description Operations

A composite location storage represents an object or value which may be
contained in part of another location storage or contained in parts of more than
one location storage.

Each part has a part location description L and a part bit size S. L can have
one or more single location descriptions SL. If there are more than one SL then
that indicates that part is located in more than one place. The bits of each
place of the part comprise S contiguous bits from the location storage LS
specified by SL starting at the bit offset specified by SL. All the bits must be
within the size of LS or the DWARF expression is ill-formed.

A composite location storage can have zero or more parts. The parts are
contiguous such that the zero-based location storage bit index will range over
each part with no gaps between them. Therefore, the size of a composite location
storage is the sum of the size of its parts. The DWARF expression is ill-formed
if the size of the contiguous location storage is larger than the size of the
memory location storage corresponding to the largest target architecture
specific address space.

A composite location description specifies a composite location storage. The bit
offset corresponds to a bit position within the composite location storage.

There are operations that create a composite location storage.

There are other operations that allow a composite location storage to be
incrementally created. Each part is created by a separate operation. There may
be one or more operations to create the final composite location storage. A
series of such operations describes the parts of the composite location storage
that are in the order that the associated part operations are executed.

To support incremental creation, a composite location storage can be in an
incomplete state. When an incremental operation operates on an incomplete
composite location storage, it adds a new part, otherwise it creates a new
composite location storage. The DW_OP_piece_end operation explicitly makes an
incomplete composite location storage complete.

A composite location description that specifies a composite location storage
that is incomplete is termed an incomplete composite location description. A
composite location description that specifies a composite location storage that
is complete is termed a complete composite location description.

If the top stack entry is a location description that has one incomplete
composite location description SL after the execution of an operation expression
has completed, SL is converted to a complete composite location description.

[non-normative] Note that this conversion does not happen after the completion
of an operation expression that is evaluated on the same stack by the
DW_OP_call* operations. Such executions are not a separate evaluation of an
operation expression, but rather the continued evaluation of the same operation
expression that contains the DW_OP_call* operation.

If a stack entry is required to be a location description L, but L has an
incomplete composite location description, then the DWARF expression is
ill-formed. The exception is for the operations involved in incrementally
creating a composite location description as described below.

[non-normative] Note that a DWARF operation expression may arbitrarily compose
composite location descriptions from any other location description, including
those that have multiple single location descriptions, and those that have
composite location descriptions.

[non-normative] The incremental composite location description operations are
defined to be compatible with the definitions in DWARF Version 5.

1.  DW_OP_piece
    DW_OP_piece has a single unsigned LEB128 integer that represents a byte size
    S.

    The action is based on the context:

      * If the stack is empty, then a location description L comprised of one
        incomplete composite location description SL is pushed on the stack.

        An incomplete composite location storage LS is created with a single
        part P. P specifies a location description PL and has a bit size of S
        scaled by 8 (the byte size). PL is comprised of one undefined location
        description PSL.

        SL specifies LS with a bit offset of 0.

      * Otherwise, if the top stack entry is a location description L comprised
        of one incomplete composite location description SL, then the incomplete
        composite location storage LS that SL specifies is updated to append a
        new part P. P specifies a location description PL and has a bit size of
        S scaled by 8 (the byte size). PL is comprised of one undefined location
        description PSL. L is left on the stack.

      * Otherwise, if the top stack entry is a location description or can be
        converted to one, then it is popped and treated as a part location
        description PL. Then:

          * If the top stack entry (after popping PL) is a location description
            L comprised of one incomplete composite location description SL,
            then the incomplete composite location storage LS that SL specifies
            is updated to append a new part P. P specifies the location
            description PL and has a bit size of S scaled by 8 (the byte size).
            L is left on the stack.

          * Otherwise, a location description L comprised of one incomplete
            composite location description SL is pushed on the stack.

            An incomplete composite location storage LS is created with a single
            part P. P specifies the location description PL and has a bit size
            of S scaled by 8 (the byte size).

            SL specifies LS with a bit offset of 0.

      * Otherwise, the DWARF expression is ill-formed

    [non-normative] Many compilers store a single variable in sets of registers
    or store a variable partially in memory and partially in registers.
    DW_OP_piece provides a way of describing where a part of a variable is
    located.

    [non-normative] If a non-0 byte displacement is required, the DW_OP_offset
    operation can be used to update the location description before using it as
    the part location description of a DW_OP_piece operation.

    [non-normative] The evaluation rules for the DW_OP_piece operation allow it
    to be compatible with the DWARF Version 5 definition.

    > [For further discussion...]
    > Since these extensions allow location descriptions to be entries on the
    > stack, a simpler operation to create composite location descriptions could
    > be defined. For example, just one operation that specifies how many parts,
    > and pops pairs of stack entries for the part size and location
    > description. Not only would this be a simpler operation and avoid the
    > complexities of incomplete composite location descriptions, but it may
    > also have a smaller encoding in practice. However, the desire for
    > compatibility with DWARF Version 5 is likely a stronger consideration.

2.  DW_OP_bit_piece
    DW_OP_bit_piece has two operands. The first is an unsigned LEB128 integer
    that represents the part bit size S. The second is an unsigned LEB128
    integer that represents a bit displacement B.

    The action is the same as for DW_OP_piece, except that any part created has
    the bit size S, and the location description PL of any created part is
    updated as if the DW_OP_constu B; DW_OP_bit_offset operations were applied.

    [non-normative] DW_OP_bit_piece is used instead of DW_OP_piece when the
    piece to be assembled is not byte-sized or is not at the start of the part
    location description.

    [non-normative] If a computed bit displacement is required, the
    DW_OP_bit_offset operation can be used to update the location description
    before using it as the part location description of a DW_OP_bit_piece
    operation.

3.  DW_OP_piece_end
    If the top stack entry is not a location description L comprised of one
    incomplete composite location description SL, then the DWARF expression is
    ill-formed.

    Otherwise, the incomplete composite location storage LS specified by SL is
    updated to be a complete composite location description with the same
    parts.

4.  DW_OP_overlay
    DW_OP_overlay pops four stack entries. The first must be an integral type
    value that represents the overlay byte size value S. The second must be an
    integral type value that represents the overlay byte offset value O. The
    third must be a location description that represents the overlay location
    description OL. The fourth must be a location description that represents
    the base location description BL.

    The action is the same as for DW_OP_bit_overlay, except that the overlay
    bit size BS and overlay bit offset BO used are S and O respectively scaled
    by 8 (the byte size).

5.  DW_OP_bit_overlay
    DW_OP_bit_overlay pops four stack entries. The first must be an integral
    type value that represents the overlay bit size value BS. The second must
    be an integral type value that represents the overlay bit offset value BO.
    The third must be a location description that represents the overlay
    location description OL. The fourth must be a location description that
    represents the base location description BL.

    The DWARF expression is ill-formed if BS or BO are negative values.

    rbss(L) is the minimum remaining bit storage size of L which is defined as
    follows. LS is the location storage and LO is the location bit offset
    specified by a single location description SL of L. The remaining bit
    storage size RBSS of SL is the bit size of LS minus LO. rbss(L) is the
    minimum RBSS of each single location description SL of L.

    The DWARF expression is ill-formed if rbss(BL) is less than BO plus BS.

    If BS is 0, then the operation pushes BL.

    If BO is 0 and BS equals rbss(BL), then the operation pushes OL.

    Otherwise, the operation is equivalent to performing the following steps to
    push a composite location description.

    [non-normative] The composite location description is conceptually the base
    location description BL with the overlay location description OL positioned
    as an overlay starting at the overlay offset BO and covering overlay bit
    size BS.

    1.  If BO is not 0 then push BL followed by performing the DW_OP_bit_piece
        BO, 0 operation.
    2.  Push OL followed by performing the DW_OP_bit_piece BS, 0 operation.
    3.  If rbss(BL) is greater than BO plus BS, push BL followed by performing
        the DW_OP_bit_piece (rbss(BL) - BO - BS), (BO + BS) operation.
    4.  Perform the DW_OP_piece_end operation.

6.  DW_OP_extend
    DW_OP_extend has two operands. The first is an unsigned LEB128 integer that
    represents the element bit size S. The second is an unsigned LEB128 integer
    that represents a count C.

    It pops one stack entry that must be a location description and is treated
    as the part location description PL.

    A location description L comprised of one complete composite location
    description SL is pushed on the stack.

    A complete composite location storage LS is created with C identical parts
    P. Each P specifies PL and has a bit size of S.

    SL specifies LS with a bit offset of 0.

    The DWARF expression is ill-formed if the element bit size or count are 0.

7.  DW_OP_select_bit_piece
    DW_OP_select_bit_piece has two operands. The first is an unsigned LEB128
    integer that represents the element bit size S. The second is an unsigned
    LEB128 integer that represents a count C.

    It pops three stack entries. The first must be an integral type value that
    represents a bit mask value M. The second must be a location description
    that represents the one-location description L1. The third must be a
    location description that represents the zero-location description L0.

    A complete composite location storage LS is created with C parts PN ordered
    in ascending N from 0 to C-1 inclusive. Each PN specifies location
    description PLN and has a bit size of S.

    PLN is as if the DW_OP_bit_offset N*S operation was applied to PLXN.

    PLXN is the same as L0 if the Nth least significant bit of M is a zero,
    otherwise it is the same as L1.

    A location description L comprised of one complete composite location
    description SL is pushed on the stack. SL specifies LS with a bit offset of
    0.

    The DWARF expression is ill-formed if S or C are 0, or if the bit size of M
    is less than C.

> [For further discussion...]
> Should the count operand for DW_OP_extend and DW_OP_select_bit_piece be
> changed to get the count value off the stack? This would allow support for
> architectures that have variable length vector instructions such as ARM and
> RISC-V.

2.5.5 DWARF Location List Expressions

[non-normative] To meet the needs of recent computer architectures and
optimization techniques, debugging information must be able to describe the
location of an object whose location changes over the object’s lifetime, and may
reside at multiple locations during parts of an object’s lifetime. Location list
expressions are used in place of operation expressions whenever the object whose
location is being described has these requirements.

A location list expression consists of a series of location list entries. Each
location list entry is one of the following kinds:

  * Bounded location description. This kind of location list entry provides an
    operation expression that evaluates to the location description of an object
    that is valid over a lifetime bounded by a starting and ending address. The
    starting address is the lowest address of the address range over which the
    location is valid. The ending address is the address of the first location
    past the highest address of the address range.

    The location list entry matches when the current program location is within
    the given range.

    There are several kinds of bounded location description entries which differ
    in the way that they specify the starting and ending addresses.

  * Default location description. This kind of location list entry provides an
    operation expression that evaluates to the location description of an object
    that is valid when no bounded location description entry applies.

    The location list entry matches when the current program location is not
    within the range of any bounded location description entry.

  * Base address. This kind of location list entry provides an address to be
    used as the base address for beginning and ending address offsets given in
    certain kinds of bounded location description entries. The applicable base
    address of a bounded location description entry is the address specified by
    the closest preceding base address entry in the same location list. If there
    is no preceding base address entry, then the applicable base address
    defaults to the base address of the compilation unit (see Section 3.1.1 on
    page 60).

    In the case of a compilation unit where all of the machine code is contained
    in a single contiguous section, no base address entry is needed.

  * End-of-list. This kind of location list entry marks the end of the location
    list expression.

The address ranges defined by the bounded location description entries of a
location list expression may overlap. When they do, they describe a situation in
which an object exists simultaneously in more than one place.

If all of the address ranges in a given location list expression do not
collectively cover the entire range over which the object in question is
defined, and there is no following default location description entry, it is
assumed that the object is not available for the portion of the range that is
not covered.

The result of the evaluation of a DWARF location list expression is:

  * If the current program location is not specified, then it is an evaluation
    error.

    > [For further discussion...]
    > If the location list only has a single default entry, should that be
    > considered a match if there is no program location? If there are
    > non-default entries then it seems it has to be an evaluation error when
    > there is no program location as that indicates the location depends on the
    > program location which is not known.

  * If there are no matching location list entries, then the result is a
    location description that comprises one undefined location description.

  * Otherwise, the operation expression E of each matching location list entry
    is evaluated with the current context, except that the result kind is a
    location description, the object is unspecified, and the initial stack is
    empty. The location list entry result is the location description returned
    by the evaluation of E.

    The result is a location description that is comprised of the union of the
    single location descriptions of the location description result of each
    matching location list entry.

A location list expression can only be used as the value of a debugger
information entry attribute that is encoded using class loclist or loclistsptr
(see 7.5.5 Classes and Forms). The value of the attribute provides an index into
a separate object file section called .debug_loclists or .debug_loclists.dwo
(for split DWARF object files) that contains the location list entries.

A DW_OP_call* and DW_OP_implicit_pointer operation can be used to specify a
debugger information entry attribute that has a location list expression.
Several debugger information entry attributes allow DWARF expressions that are
evaluated with an initial stack that includes a location description that may
originate from the evaluation of a location list expression.

[non-normative] This location list representation, the loclist and loclistsptr
class, and the related DW_AT_loclists_base attribute are new in DWARF Version 5.
Together they eliminate most, or all of the code object relocations previously
needed for location list expressions.

Each location list entry begins with a single byte identifying the kind of that
entry, followed by zero or more operands depending on the kind.

In the descriptions that follow, these terms are used for operands:

  * A counted location description operand consists of an unsigned ULEB integer
    giving the length of the location description (see Section 2.6.1 on page 39)
    that immediately follows.

  * An address index operand is the index of an address in the .debug_addr
    section. This index is relative to the value of the DW_AT_addr_base
    attribute of the associated compilation unit. The address given by this kind
    of operand is not relative to the compilation unit base address.

  * A target address operand is an address on the target machine. (Its size is
    the same as used for attribute values of class address, specifically,
    DW_FORM_addr.)

The following entry kinds are defined for use in both split or non-split units:

1.  DW_LLE_end_of_list
    An end-of-list entry contains no further data.

    [non-normative] A series of this kind of entry may be used for padding or
    alignment purposes.

2.  DW_LLE_base_addressx
    This is a form of base address entry that has one unsigned LEB128 operand.
    The operand value is an address index (into the .debug_addr section) that
    indicates the applicable base address used by subsequent DW_LLE_offset_pair
    entries.

3.  DW_LLE_startx_endx
    This is a form of bounded location description entry that has two unsigned
    LEB128 operands. The operand values are address indices (into the
    .debug_addr section). These indicate the starting and ending addresses,
    respectively, that define the address range for which this location is
    valid. These operands are followed by a counted location description.

4.  DW_LLE_startx_length
    This is a form of bounded location description that has two unsigned ULEB
    operands. The first value is an address index (into the .debug_addr section)
    that indicates the beginning of the address range over which the location is
    valid. The second value is the length of the range. These operands are
    followed by a counted location description.

5.  DW_LLE_offset_pair
    This is a form of bounded location description entry that has two unsigned
    LEB128 operands. The values of these operands are the starting and ending
    offsets, respectively, relative to the applicable base address, that define
    the address range for which this location is valid. These operands are
    followed by a counted location description.

6.  DW_LLE_default_location
    The operand is a counted location description which defines where an object
    is located if no prior location description is valid.

The following kinds of location list entries are defined for use only in
non-split DWARF units:

7.  DW_LLE_base_address
    A base address entry has one target address operand. This address is used as
    the base address when interpreting offsets in subsequent location list
    entries of kind DW_LLE_offset_pair.

8.  DW_LLE_start_end
    This is a form of bounded location description entry that has two target
    address operands. These indicate the starting and ending addresses,
    respectively, that define the address range for which the location is valid.
    These operands are followed by a counted location description.

9.  DW_LLE_start_length
    This is a form of bounded location description entry that has one target
    address operand value and an unsigned LEB128 integer operand value. The
    address is the beginning address of the range over which the location
    description is valid, and the length is the number of bytes in that range.
    These operands are followed by a counted location description.

2.12 Segmented Addresses

[non-normative] In some systems, addresses are specified as offsets within a
given segment rather than as locations within a single flat address space.

Any debugging information entry that contains a description of the location of
an object or subroutine may have a DW_AT_segment attribute, whose value is a
location description. The description evaluates to the segment selector of the
item being described. If the entry containing the DW_AT_segment attribute has a
DW_AT_low_pc, DW_AT_high_pc, DW_AT_ranges or DW_AT_entry_pc attribute, or a
location description that evaluates to an address, then those address values
represent the offset portion of the address within the segment specified by
DW_AT_segment.

If an entry has no DW_AT_segment attribute, it inherits the segment value from
its parent entry. If none of the entries in the chain of parents for this entry
back to its containing compilation unit entry have DW_AT_segment attributes,
then the entry is assumed to exist within a flat address space. Similarly, if
the entry has a DW_AT_segment attribute containing an empty location
description, that entry is assumed to exist within a flat address space.

[non-normative] Some systems support different classes of addresses. The address
class may affect the way a pointer is dereferenced or the way a subroutine is
called.

Any debugging information entry representing a pointer or reference type or a
subroutine or subroutine type may have a DW_AT_address_class attribute, whose
value is an integer constant. The set of permissible values is specific to each
target architecture. The value DW_ADDR_none, however, is common to all
encodings, and means that no address class has been specified.

[non-normative] For example, the Intel386 TM processor might use the following
values:

Table 2.7: Example address class codes
-------------- ------ --------------------------------
Name           Value  Meaning
-------------- ------ --------------------------------
DW_ADDR_none   0      no class specified
DW_ADDR_near16 1      16-bit offset, no segment
DW_ADDR_far16  2      16-bit offset, 16-bit segment
DW_ADDR_huge16 3      16-bit offset, 16-bit segment
DW_ADDR_near32 4      32-bit offset, no segment
DW_ADDR_far32  5      32-bit offset, 16-bit segment
-------------- ------ --------------------------------

2.13 Address Spaces

DWARF address spaces correspond to target architecture specific linear
addressable memory areas. They are used in DWARF expression location
descriptions to describe in which target architecture specific memory area data
resides.

[non-normative] Target architecture specific DWARF address spaces may correspond
to hardware supported facilities such as memory utilizing base address
registers, scratchpad memory, and memory with special interleaving. The size of
addresses in these address spaces may vary. Their access and allocation may be
hardware managed with each thread or group of threads having access to
independent storage. For these reasons they may have properties that do not
allow them to be viewed as part of the unified global virtual address space
accessible by all threads.

[non-normative] It is target architecture specific whether multiple DWARF
address spaces are supported and how source language memory spaces map to target
architecture specific DWARF address spaces. A target architecture may map
multiple source language memory spaces to the same target architecture specific
DWARF address class. Optimization may determine that variable lifetime and
access pattern allows them to be allocated in faster scratchpad memory
represented by a different DWARF address space than the default for the source
language memory space.

Although DWARF address space identifiers are target architecture specific,
DW_ASPACE_none is a common address space supported by all target architectures,
and defined as the target architecture default address space.

DWARF address space identifiers are used by:

* The DW_AT_address_space attribute.

* The DWARF expression operations: DW_OP_aspace_bregx,
  DW_OP_form_aspace_address, DW_OP_aspace_implicit_pointer, and DW_OP_xderef*.

* The CFI instructions: DW_CFA_def_aspace_cfa and DW_CFA_def_aspace_cfa_sf.

> [For further discussion...]
> Currently, DWARF defines address class values as being target architecture
> specific, and defines a DW_AT_address_class attribute. With the removal of
> DW_AT_segment in DWARF 6, it is unclear how the address class is intended to
> be used as the term is not used elsewhere. Should these be replaced by this
> proposal's more complete address space? Or are they intended to represent
> source language memory spaces such as in OpenCL?

2.14 Memory Spaces

DWARF memory spaces are used for source languages that have the concept of
memory spaces. They are used in the DW_AT_memory_space attribute for pointer
type, reference type, variable, formal parameter, and constant debugger
information entries.

Each DWARF memory space is conceptually a separate source language memory space
with its own lifetime and aliasing rules. DWARF memory spaces are used to
specify the source language memory spaces that pointer type and reference type
values refer, and to specify the source language memory space in which variables
are allocated.

Although DWARF memory space identifiers are source language specific,
DW_MSPACE_none is a common memory space supported by all source languages, and
defined as the source language default memory space.

The set of currently defined DWARF memory spaces, together with source language
mappings, is given in Table 2.x "Source language memory space".

Vendor defined source language memory spaces may be defined using codes in the
range DW_MSPACE_lo_user to DW_MSPACE_hi_user.

Table 2.x: Source language memory spaces
================== ============ ============== ============== ==============
Memory Space Name  Meaning      C/C++          OpenCL         CUDA/HIP
================== ============ ============== ============== ==============
DW_MSPACE_none     generic      <i>default</i> generic        <i>default</i>
DW_MSPACE_global   global                      global
DW_MSPACE_constant constant                    constant       constant
DW_MSPACE_group    thread-group                local          shared
DW_MSPACE_private  thread                      private
DW_MSPACE_lo_user
DW_MSPACE_hi_user
================== ============ ============== ============== ==============

> [For further discussion...]
> The approach presented in Table 2.x "Source language memory spaces" is to
> define the default DW_MSPACE_none to be the generic address class and not the
> global address class. This matches how CLANG and LLVM have added support for
> CUDA-like languages on top of existing C++ language support. This allows all
> addresses to be generic by default which matches CUDA-like languages.
>
> An alternative approach is to define DW_MSPACE_none as being the global memory
> space and then change DW_MSPACE_global to DW_MSPACE_generic. This would match
> the reality that languages that do not support multiple memory spaces only
> have one default global memory space. Generally, in these languages if they
> expose that the target architecture supports multiple memory spaces, the
> default one is still the global memory space. Then a language that does
> support multiple memory spaces has to explicitly indicate which pointers have
> the added ability to reference more than the global memory space. However,
> compilers generating DWARF for CUDA-like languages would then have to define
> every CUDA-like language pointer type or reference type with a
> DW_AT_memory_space attribute of DW_MSPACE_generic to match the language
> semantics.

3.1.1 Full and Partial Compilation Unit Entries

Table 3.1: Language names
------------------ ---------------------
Language name      Meaning
------------------ ---------------------
...
DW_LANG_HIP        HIP
------------------ ---------------------

3.3.5 Low-Level Information

A DW_TAG_subprogram, DW_TAG_inlined_subroutine, or DW_TAG_entry_point debugger
information entry may have a DW_AT_return_addr attribute, whose value is a DWARF
expression E.

The result of the attribute is obtained by evaluating E with a context that has
a result kind of a location description, an unspecified object, the compilation
unit that contains E, an empty initial stack, and other context elements
corresponding to the source language thread of execution upon which the user is
focused, if any. The result of the evaluation is the location description L of
the place where the return address for the current call frame’s subprogram or
entry point is stored.

The DWARF is ill-formed if L is not comprised of one memory location description
for one of the target architecture specific address spaces.

> [For further discussion...]
> NOTE: It is unclear why DW_TAG_inlined_subroutine has a DW_AT_return_addr
> attribute but not a DW_AT_frame_base or DW_AT_static_link attribute. Seems it
> would either have all of them or none. Since inlined subprograms do not have a
> call frame it seems they would have none of these attributes.

A DW_TAG_subprogram or DW_TAG_entry_point debugger information entry may have a
DW_AT_frame_base attribute, whose value is a DWARF expression E.

The result of the attribute is obtained by evaluating E with a context that has
a result kind of a location description, an unspecified object, the compilation
unit that contains E, an empty initial stack, and other context elements
corresponding to the source language thread of execution upon which the user is
focused, if any.

The DWARF is ill-formed if E contains a DW_OP_fbreg operation, or the resulting
location description L is not comprised of one single location description SL.

If SL is a register location description for register R, then L is replaced with
the result of evaluating a DW_OP_bregx R, 0 operation. This computes the frame
base memory location description in the target architecture default address
space.

[non-normative] This allows the more compact DW_OP_reg* to be used instead of
DW_OP_breg* 0.

> [For further discussion...]
> This rule could be removed and require the producer to create the required
> location description directly using DW_OP_call_frame_cfa, DW_OP_breg*, or
> DW_OP_aspace_bregx. This would also then allow a target to implement the call
> frames within a large register.

Otherwise, the DWARF is ill-formed if SL is not a memory location description in
any of the target architecture specific address spaces.

The resulting L is the <i>frame base</i> for the subprogram or entry point.

[non-normative] Typically, E will use the DW_OP_call_frame_cfa operation or be a
stack pointer register plus or minus some offset.

[non-normative] The frame base for a subprogram is typically an address relative
to the first unit of storage allocated for the subprogram's stack frame. The
DW_AT_frame_base attribute can be used in several ways:

1.  [non-normative] In subprograms that need location lists to locate local
    variables, the DW_AT_frame_base can hold the needed location list, while all
    variables' location descriptions can be simpler ones involving the frame
    base.

2.  [non-normative] It can be used in resolving "up-level" addressing within
    nested routines. (See also DW_AT_static_link, below)

[non-normative] Some languages support nested subroutines. In such languages, it
is possible to reference the local variables of an outer subroutine from within
an inner subroutine. The DW_AT_static_link and DW_AT_frame_base attributes allow
debuggers to support this same kind of referencing.

If a DW_TAG_subprogram or DW_TAG_entry_point debugger information entry is
lexically nested, it may have a DW_AT_static_link attribute, whose value is a
DWARF expression E.

The result of the attribute is obtained by evaluating E with a context that has
a result kind of a location description, an unspecified object, the compilation
unit that contains E, an empty initial stack, and other context elements
corresponding to the source language thread of execution upon which the user is
focused, if any. The result of the evaluation is the location description L of
the <i>canonical frame address</i> (see 6.4 Call Frame Information) of the
relevant call frame of the subprogram instance that immediately lexically
encloses the current call frame’s subprogram or entry point.

The DWARF is ill-formed if L is not comprised of one memory location description
for one of the target architecture specific address spaces.

In the context of supporting nested subroutines, the DW_AT_frame_base attribute
value obeys the following constraints:

1.  It computes a value that does not change during the life of the subprogram,
    and

2.  The computed value is unique among instances of the same subroutine.

    [non-normative] For typical DW_AT_frame_base use, this means that a
    recursive subroutine's stack frame must have non-zero size.

[non-normative] If a debugger is attempting to resolve an up-level reference to
a variable, it uses the nesting structure of DWARF to determine which subroutine
is the lexical parent and the DW_AT_static_link value to identify the
appropriate active frame of the parent. It can then attempt to find the
reference within the context of the parent.

For languages that are implemented using a SIMD/SIMT execution model, a
DW_TAG_subprogram, DW_TAG_inlined_subroutine, or DW_TAG_entry_point debugger
information entry may have a DW_AT_lanes attribute whose value is an integer
constant or a DWARF expression E. Its value is the number of lanes in use by the
target architecture threads.

If the attribute is an integer constant, then the value is the constant. The
DWARF is ill-formed if the constant is less than or equal to 0.

Otherwise, E is evaluated with a context that has a result kind of a location
description, an unspecified object, the compilation unit that contains E, an
empty initial stack, and other context elements corresponding to the source
language thread of execution upon which the user is focused, if any. The DWARF
is ill-formed if the result is not a location description comprised of one
implicit location description, that when read as the generic type, results in a
value V that is greater than 0. The result of the attribute is the value V.

If not present, the default value of 1 is used.

[non-normative] For a vectorized SIMD execution model, its value is the number
of source language loop iterations executing concurrently by the target
architecture thread for a single source language thread of execution. The number
of concurrent iterations may vary for different loop nests in the same
subprogram. Typically, this attribute will use a loclist to express different
values at different program locations.

[non-normative] For a SIMT execution model, a compiler may map source language
threads of execution onto lanes of a target architecture thread. It is the
static number of source language threads of execution per target architecture
thread. It is not the dynamic number of source language threads of execution
with which the target architecture thread was initiated, for example, due to
smaller or partial work-groups. Typically, this attribute will use a constant
for target architectures with a fixed lane count, and an operation expression
for target architectures that support implementation specific lane counts.

5.  For source languages that are implemented using a SIMT execution model, a
    DW_TAG_subprogram, DW_TAG_inlined_subroutine, or DW_TAG_entry_point
    debugging information entry may have a DW_AT_lane_pc attribute whose value
    is a DWARF expression E.

    The result of the attribute is obtained by evaluating E with a context that
    has a result kind of a location description, an unspecified object, the
    compilation unit that contains E, an empty initial stack, and other context
    elements corresponding to the source language thread of execution upon
    which the user is focused, if any.

    The resulting location description L is for a lane count sized vector of
    generic type elements. The lane count is the value of the DW_AT_lanes
    attribute. Each element holds the conceptual program location of the
    corresponding lane. If the lane was not active when the current subprogram
    was called, its element is an undefined location description.

    The DWARF is ill-formed if L does not have exactly one single location
    description.

    [non-normative] DW_AT_lane_pc allows the compiler to indicate conceptually
    where each SIMT lane of a target architecture thread is positioned even
    when it is in divergent control flow that is not active.

    [non-normative] Typically, the result is a location description with one
    composite location description with each part being a location description
    with either one undefined location description or one memory location
    description.

    If not present, the target architecture thread is not being used in a SIMT
    manner, and the thread's current program location is used.

6.  For languages that are implemented using a SIMT execution model, a
    DW_TAG_subprogram, DW_TAG_inlined_subroutine, or DW_TAG_entry_point
    debugger information entry may have a DW_AT_active_lane attribute whose
    value is a DWARF expression E.

    E is evaluated with a context that has a result kind of a location
    description, an unspecified object, the compilation unit that contains E,
    an empty initial stack, and other context elements corresponding to the
    source language thread of execution upon which the user is focused, if any.

    The DWARF is ill-formed if L does not have exactly one single location
    description SL.

    The active lane bit mask V for the current program location is obtained by
    reading from SL using a target architecture specific integral base type T
    that has a bit size equal to the value of the DW_AT_lanes attribute of the
    subprogram corresponding to context's frame and program location. The Nth
    least significant bit of the mask corresponds to the Nth lane. If the bit
    is 1 the lane is active, otherwise it is inactive. The result of the
    attribute is the value V.

    [non-normative] Some targets may update the target architecture execution
    mask for regions of code that must execute with different sets of lanes
    than the current active lanes. For example, some code must execute with all
    lanes made temporarily active. DW_AT_active_lane allows the compiler to
    provide the means to determine the source language active lanes at any
    program location. Typically, this attribute will use a loclist to express
    different locations of the active lane mask at different program locations.

    If not present and DW_AT_lanes is greater than 1, then the target
    architecture execution mask is used.

3.4.2 Call Site Parameters

The call site entry may own DW_TAG_call_site_parameter debugging information
entries representing the parameters passed to the call. Call site parameter
entries occur in the same order as the corresponding parameters in the source.
Each such entry has a DW_AT_location attribute which is a location description.
This location description describes where the parameter is passed (usually
either some register, or a memory location expressible as the contents of the
stack register plus some offset).

A DW_TAG_call_site_parameter debugger information entry may have a
DW_AT_call_value attribute, whose value is a DWARF operation expression E1.

The result of the DW_AT_call_value attribute is obtained by evaluating E1 with a
context that has a result kind of a value, an unspecified object, the
compilation unit that contains E, an empty initial stack, and other context
elements corresponding to the source language thread of execution upon which the
user is focused, if any. The resulting value V1 is the value of the parameter at
the time of the call made by the call site.

For parameters passed by reference, where the code passes a pointer to a
location which contains the parameter, or for reference type parameters, the
DW_TAG_call_site_parameter debugger information entry may also have a
DW_AT_call_data_location attribute whose value is a DWARF operation expression
E2, and a DW_AT_call_data_value attribute whose value is a DWARF operation
expression E3.

The value of the DW_AT_call_data_location attribute is obtained by evaluating E2
with a context that has a result kind of a location description, an unspecified
object, the compilation unit that contains E, an empty initial stack, and other
context elements corresponding to the source language thread of execution upon
which the user is focused, if any. The resulting location description L2 is the
location where the referenced parameter lives during the call made by the call
site. If E2 would just be a DW_OP_push_object_address, then the
DW_AT_call_data_location attribute may be omitted.

> [For further discussion...]
> The DWARF Version 5 implies that DW_OP_push_object_address may be used but
> does not state what object must be specified in the context. Either
> DW_OP_push_object_address cannot be used, or the object to be passed in the
> context must be defined.

The value of the DW_AT_call_data_value attribute is obtained by evaluating E3
with a context that has a result kind of a value, an unspecified object, the
compilation unit that contains E, an empty initial stack, and other context
elements corresponding to the source language thread of execution upon which the
user is focused, if any. The resulting value V3 is the value in L2 at the time
of the call made by the call site.

The result of these attributes is undefined if the current call frame is not for
the subprogram containing the DW_TAG_call_site_parameter debugger information
entry or the current program location is not for the call site containing the
DW_TAG_call_site_parameter debugger information entry in the current call frame.

[non-normative] The consumer may have to virtually unwind to the call site (see
6.4 Call Frame Information) in order to evaluate these attributes. This will
ensure the source language thread of execution upon which the user is focused
corresponds to the call site needed to evaluate the expression.

If it is not possible to avoid the expressions of these attributes from
accessing registers or memory locations that might be clobbered by the
subprogram being called by the call site, then the associated attribute should
not be provided.

[non-normative] The reason for the restriction is that the parameter may need to
be accessed during the execution of the callee. The consumer may virtually
unwind from the called subprogram back to the caller and then evaluate the
attribute expressions. The call frame information (see 6.4 Call Frame
Information) will not be able to restore registers that have been clobbered, and
clobbered memory will no longer have the value at the time of the call.

Each call site parameter entry may also have a DW_AT_call_parameter attribute
which contains a reference to a DW_TAG_formal_parameter entry, DW_AT_type
attribute referencing the type of the parameter or DW_AT_name attribute
describing the parameter's name.

[non-normative] Examples using call site entries and related attributes are
found in Appendix D.15 on page 353.

4.1 Data Object Entries

Program variables, formal parameters and constants are represented by debugging
information entries with the tags DW_TAG_variable, DW_TAG_formal_parameter and
DW_TAG_constant, respectively.

[non-normative] The tag DW_TAG_constant is used for languages that have true
named constants.

The debugging information entry for a program variable, formal parameter or
constant may have the following attributes:

1.  A DW_AT_name attribute, whose value is a null-terminated string containing
    the data object name.

    If a variable entry describes an anonymous object (for example an anonymous
    union), the name attribute is omitted or its value consists of a single zero
    byte.

2.  A DW_AT_external attribute, which is a flag, if the name of a variable is 
    visible outside of its enclosing compilation unit.

    [non-normative] The definitions of C++ static data members of structures or
    classes are represented by variable entries flagged as external. Both file
    static and local variables in C and C++ are represented by non-external
    variable entries.

3.  A DW_AT_declaration attribute, which is a flag that indicates whether this
    entry represents a non-defining declaration of an object.

4.  A DW_AT_location attribute, whose value is a DWARF expression E that
    describes the location of a variable or parameter at run-time.

    The result of the attribute is obtained by evaluating E with a context that
    has a result kind of a location description, an unspecified object, the
    compilation unit that contains E, an empty initial stack, and other context
    elements corresponding to the source language thread of execution upon which
    the user is focused, if any. The result of the evaluation is the location
    description of the base of the data object.

    See 2.5.4.2 Control Flow Operations for special evaluation rules used by the
    DW_OP_call* operations.

    > [For further discussion...]
    > NOTE: Delete the description of how the DW_OP_call* operations evaluate a
    > DW_AT_location attribute as that is now described in the operations.
    >
    > NOTE: See the discussion about the DW_AT_location attribute in the
    > DW_OP_call* operation. Having each attribute only have a single purpose
    > and single execution semantics seems desirable. It makes it easier for the
    > consumer that no longer have to track the context. It makes it easier for
    > the producer as it can rely on a single semantics for each attribute.
    >
    > For that reason, limiting the DW_AT_location attribute to only supporting
    > evaluating the location description of an object, and using a different
    > attribute and encoding class for the evaluation of DWARF expression
    > procedures on the same operation expression stack seems desirable.

    If no location attribute is present in a variable entry representing the
    definition of a variable (that is, with no DW_AT_declaration attribute), or
    if the location attribute is present but has an empty location description
    (as described in Section 2.6 on page 38), the variable is assumed to exist
    in the source code but not in the executable program (but see number 10,
    below).

    In a variable entry representing a non-defining declaration of a variable,
    the location specified supersedes the location specified by the defining
    declaration but only within the scope of the variable entry; if no location
    is specified, then the location specified in the defining declaration
    applies.

    [non-normative] This can occur, for example, for a C or C++ external
    variable (one that is defined and allocated in another compilation unit) and
    whose location varies in the current unit due to optimization.

    The location of a variable may be further specified with a DW_AT_segment
    attribute, if appropriate.

5.  A DW_AT_type attribute describing the type of the variable, constant or
    formal parameter.

6.  If the variable entry represents the defining declaration for a C++ static
    data member of a structure, class or union, the entry has a
    DW_AT_specification attribute, whose value is a reference to the debugging
    information entry representing the declaration of this data member. The
    referenced entry also has the tag DW_TAG_variable and will be a child of
    some class, structure or union type entry.

    If the variable entry represents a non-defining declaration,
    DW_AT_specification may be used to reference the defining declaration of the
    variable. If no DW_AT_specification attribute is present, the defining
    declaration may be found as a global definition either in the current
    compilation unit or in another compilation unit with the DW_AT_external
    attribute.

    Variable entries containing the DW_AT_specification attribute do not need to
    duplicate information provided by the declaration entry referenced by the
    specification attribute. In particular, such variable entries do not need to
    contain attributes for the name or type of the data member whose definition
    they represent.

7.  A DW_AT_variable_parameter attribute, which is a flag, if a formal
    parameter entry represents a parameter whose value in the calling function
    may be modified by the callee. The absence of this attribute implies that
    the parameter's value in the calling function cannot be modified by the
    callee.

8.  A DW_AT_is_optional attribute, which is a flag, if a parameter entry
    represents an optional parameter.

9.  A DW_AT_default_value attribute for a formal parameter entry. The value of
    this attribute may be a constant, or a reference to the debugging
    information entry for a variable, or a reference to a debugging information
    entry containing a DWARF procedure. If the attribute form is of class
    constant, that constant is interpreted as a value whose type is the same as
    the type of the formal parameter. If the attribute form is of class
    reference, and the referenced entry is for a variable, the default value of
    the parameter is the value of the referenced variable. If the reference
    value is 0, no default value has been specified. Otherwise, the attribute
    represents an implicit DW_OP_call_ref to the referenced debugging
    information entry, and the default value of the parameter is the value
    returned by that DWARF procedure, interpreted as a value of the type of the
    formal parameter.

    [non-normative] For a constant form there is no way to express the absence
    of a default value.

10. A DW_AT_const_value attribute for an entry describing a variable or formal
    parameter whose value is constant and not represented by an object in the
    address space of the program, or an entry describing a named constant. (Note
    that such an entry does not have a location attribute.) The value of this
    attribute may be a string or any of the constant data or data block forms,
    as appropriate for the representation of the variable's value. The value is
    the actual constant value of the variable, represented as it would be on the
    target architecture.

    [non-normative] One way in which a formal parameter with a constant value
    and no location can arise is for a formal parameter of an inlined subprogram
    that corresponds to a constant actual parameter of a call that is inlined.

    > [For further discussion]
    > Could deprecate using the DW_AT_const_value attribute for DW_TAG_variable
    > or DW_TAG_formal_parameter debugger information entries that have been
    > optimized to a constant. Instead, DW_AT_location could be used with a
    > DWARF expression that produces an implicit location description now that
    > any location description can be used within a DWARF expression. This
    > allows the DW_OP_call* operations to be used to push the location
    > description of any variable regardless of how it is optimized.

11. A DW_AT_endianity attribute, whose value is a constant that specifies the
    endianity of the object. The value of this attribute specifies an
    ABI-defined byte ordering for the value of the object. If omitted, the
    default endianity of data for the given type is assumed.

    The set of values and their meaning for this attribute is given in Table
    4.1. These represent the default encoding formats as defined by the target
    architecture's ABI or processor definition. The exact definition of these
    formats may differ in subtle ways for different architectures.

    Table 4.1: Endianity attribute values
    ---------------- ----------------------------------------------------------
    Name             Meaning
    ---------------- ----------------------------------------------------------
    DW_END_default   Default endian encoding (equivalent to the
                     absence of a DW_AT_endianity attribute)
    DW_END_big       Big-endian encoding
    DW_END_little    Little-endian encoding
    ---------------- ----------------------------------------------------------

12. A DW_AT_const_expr attribute, constant expression attribute which is a flag,
    if a variable entry represents a C++ object declared with the constexpr
    specifier. This attribute indicates that the variable can be evaluated as a
    compile-time constant.

    [non-normative] In C++, a variable declared with constexpr is implicitly
    const. Such a variable has a DW_AT_type attribute whose value is a reference
    to a debugging information entry describing a const qualified type.

13. A DW_AT_linkage_name attribute for a variable or constant entry as described
    in Section 2.22 on page 56.

14. A DW_AT_memory_space attribute with a constant value representing a source
    language specific DWARF memory space (see 2.14 "Memory Spaces"). If omitted,
    defaults to DW_MSPACE_none.

4.2 Common Block Entries

A Fortran common block may be described by a debugging information entry with
the tag DW_TAG_common_block.

The common block entry has a DW_AT_name attribute whose value is a
null-terminated string containing the common block name. It may also have a
DW_AT_linkage_name attribute as described in Section 2.22 on page 56.

A common block entry also has a DW_AT_location attribute whose value is a DWARF
expression E that describes the location of the common block at run-time. The
result of the attribute is obtained by evaluating E with a context that has a
result kind of a location description, an unspecified object, the compilation
unit that contains E, an empty initial stack, and other context elements
corresponding to the source language thread of execution upon which the user is
focused, if any. The result of the evaluation is the location description of the
base of the common block. See 2.5.4.2 Control Flow Operations for special
evaluation rules used by the DW_OP_call* operations.

The common block entry owns debugging information entries describing the
variables contained within the common block.

[non-normative] Fortran allows each declarer of a common block to independently
define its contents; thus, common blocks are not types.

5.1 Base Type Entries

[non-normative] A base type is a data type that is not defined in terms of other
data types. Each programming language has a set of base types that are
considered to be built into that language.

A base type is represented by a debugging information entry with the tag
DW_TAG_base_type.

A base type entry may have a DW_AT_name attribute whose value is a
null-terminated string containing the name of the base type as recognized by the
programming language of the compilation unit containing the base type entry.

A base type entry has a DW_AT_encoding attribute describing how the base type is
encoded and is to be interpreted. The DW_AT_encoding attribute is described in
Section 5.1.1 following.

A base type entry may have a DW_AT_endianity attribute as described in Section
4.1 on page 97. If omitted, the encoding assumes the representation that is the
default for the target architecture.

A base type entry has a DW_AT_byte_size attribute or a DW_AT_bit_size attribute
whose integer constant value (see Section 2.21 on page 56) is the amount of
storage needed to hold a value of the type.

[non-normative] For example, the C type int on a machine that uses 32-bit
integers is represented by a base type entry with a name attribute whose value
is "int", an encoding attribute whose value is DW_ATE_signed and a byte size
attribute whose value is 4.

If the value of an object of the given type does not fully occupy the storage
described by a byte size attribute, the base type entry may also have a
DW_AT_bit_size and a DW_AT_data_bit_offset attribute, both of whose values are
integer constant values (see Section 2.19 on page 55). The bit size attribute
describes the actual size in bits used to represent values of the given type.
The data bit offset attribute is the offset in bits from the beginning of the
containing storage to the beginning of the value. Bits that are part of the
offset are padding. If this attribute is omitted a default data bit offset of
zero is assumed.

A DW_TAG_base_type debugger information entry for a base type T may have a
DW_AT_vector_size attribute whose value is an integer constant that is the
vector type size N. The representation of a vector base type is as N contiguous
elements, each one having the representation of a base type T' that is the same
as T without the DW_AT_vector_size attribute. If a DW_TAG_base_type debugger
information entry does not have a DW_AT_vector_size attribute, then the base
type is not a vector type. The DWARF is ill-formed if N is not greater than 0.

> [For further discussion...]
> LLVM has mention of a non-upstreamed debugger information entry that is
> intended to support vector types. However, that was not for a base type so
> would not be suitable as the type of a stack value entry. But perhaps that
> could be replaced by using this attribute.

> [For further discussion...]
> Compare this with the DW_AT_GNU_vector extension supported by GNU. Is it
> better to add an attribute to the existing DW_TAG_base_type debug entry, or
> allow some forms of DW_TAG_array_type (those that have the DW_AT_GNU_vector
> attribute) to be used as stack entry value types?

A DW_TAG_base_type entry may have additional attributes that augment certain of
the base type encodings; these are described in the following section.

5.3 Type Modifier Entries

...

A modified type entry describing a pointer or reference type (using
DW_TAG_pointer_type, DW_TAG_reference_type or DW_TAG_rvalue_reference_type) may
have a DW_AT_address_class attribute to describe how objects having the given
pointer or reference type are dereferenced.

A modified type entry describing a pointer or reference type (using
DW_TAG_pointer_type, DW_TAG_reference_type or DW_TAG_rvalue_reference_type) may
have a DW_AT_memory_space attribute with a constant value representing a source
language specific DWARF memory space (see 2.14 "Memory Spaces"). If omitted,
defaults to DW_MSPACE_none.

A modified type entry describing a pointer or reference type (using
DW_TAG_pointer_type, DW_TAG_reference_type or DW_TAG_rvalue_reference_type) may
have a DW_AT_address_space attribute with a constant value AS representing an
architecture specific DWARF address space (see 2.x "Address Spaces"). If
omitted, defaults to DW_ASPACE_none. DR is the offset of a hypothetical debug
information entry D in the current compilation unit for an integral base type
matching the address size of AS. An object P having the given pointer or
reference type are dereferenced as if the DW_OP_push_object_address;
DW_OP_deref_type DR; DW_OP_constu AS; DW_OP_form_aspace_address operation
expression was evaluated with the current context except: the result kind is
location description; the initial stack is empty; and the object is the location
description of P.

> [For further discussion...]
> What if the current context does not have a current target architecture
> defined?

> [For further discussion...]
> With the expanded support for DWARF address spaces, it may be worth examining
> if they can be used for what was formerly supported by DWARF 5 segments that
> are being removed in DWARF 6. That would include specifying the address space
> of all code addresses (compilation units, subprograms, subprogram entries,
> labels, subprogram types, etc.). Either the code address attributes could be
> extended to allow a exprloc form (so that DW_OP_form_aspace_address can be
> used) or the DW_AT_address_space attribute be allowed on all DIEs that
> formerly allowed DW_AT_segment.

...

5.7.3 Derived or Extended Structures, Classes and Interfaces

[non-normative] In C++, a class (or struct) may be "derived from" or be a
"subclass of" another class. In Java, an interface may "extend" one or more
other interfaces, and a class may "extend" another class and/or "implement" one
or more interfaces. All of these relationships may be described using the
following. Note that in Java, the distinction between extends and implements is
implied by the entities at the two ends of the relationship.

A class type or interface type entry that describes a derived, extended or
implementing class or interface owns debugging information entries describing
each of the classes or interfaces it is derived from, extending or implementing,
respectively, ordered as they were in the source program. Each such entry has
the tag DW_TAG_inheritance.

An inheritance entry has a DW_AT_type attribute whose value is a reference to
the debugging information entry describing the class or interface from which the
parent class or structure of the inheritance entry is derived, extended or
implementing.

An inheritance entry for a class that derives from or extends another class or
struct also has a DW_AT_data_member_location attribute, whose value describes
the location of the beginning of the inherited type relative to the beginning
address of the instance of the derived class. There are two cases:

 1.  If the attribute is an integer constant B, it provides the offset in bytes
     from the beginning of the containing entity.
 
    The result of the attribute is obtained by evaluating a DW_OP_offset B
    operation with an initial stack comprising the location description of the
    beginning of the containing entity. The result of the evaluation is the
    location description of the base of the member entry.
 
     [non-normative] If the beginning of the containing entity is not byte
     aligned, then the beginning of the member entry has the same bit
     displacement within a byte.
 
 2.  Otherwise, the attribute must be a DWARF expression E which is evaluated
     with a context that has a result kind of a location description, an
     unspecified object, the compilation unit that contains E, an initial stack
     comprising the location description of the beginning of the containing
     entity, and other context elements corresponding to the source language
     thread of execution upon which the user is focused, if any. The result of
     the evaluation is the location description of the base of the member entry.
 
     > [For further discussion...]
     > The beginning of the containing entity can now be any location
     > description, including those with more than one single location
     > description, and those with single location descriptions that are of any
     > kind and have any bit offset.

[non-normative] The interpretation of the value of this attribute for inherited
types is the same as the interpretation for data members (see Section 5.7.6
following).

An inheritance entry may have a DW_AT_accessibility attribute. If no
accessibility attribute is present, private access is assumed for an entry of a
class and public access is assumed for an entry of a struct, union or interface.

If the class referenced by the inheritance entry serves as a C++ virtual base
class, the inheritance entry has a DW_AT_virtuality attribute.

[non-normative] For a C++ virtual base, the data member location attribute will
usually consist of a non-trivial location description.

5.7.8 Member Function Entries

A member function is represented by a debugging information entry with the tag
DW_TAG_subprogram. The member function entry may contain the same attributes and
follows the same rules as non-member global subroutine entries (see Section 3.3
on page 75).

In particular, if the member function entry is an instantiation of a member
function template, it follows the same rules as function template instantiations
(see Section 3.3.7 on page 81).

A member function entry may have a DW_AT_accessibility attribute. If no
accessibility attribute is present, private access is assumed for an entry of a
class and public access is assumed for an entry of a structure, union or
interface.

If the member function entry describes a virtual function, then that entry has a
DW_AT_virtuality attribute.

If the member function entry describes an explicit member function, then that
entry has a DW_AT_explicit attribute.

An entry for a virtual function also has a DW_AT_vtable_elem_location attribute
whose value is a DWARF expression E. The result of the attribute is obtained by
evaluating E with a context that has a result kind of a location description, an
unspecified object, the compilation unit that contains E, an initial stack
comprising the location description of the object of the enclosing type, and
other context elements corresponding to the source language thread of execution
upon which the user is focused, if any. The result of the evaluation is the
location description of the slot for the function within the virtual function
table for the enclosing class.

If the member function entry describes a non-static member function, then that
entry has a DW_AT_object_pointer attribute whose value is a reference to the
formal parameter entry that corresponds to the object for which the function is
called. The name attribute of that formal parameter is defined by the current
language (for example, this for C++ or self for Objective C and some other
languages). That parameter also has a DW_AT_artificial attribute whose value is
true.

...

5.14 Pointer to Member Type Entries

[non-normative] In C++, a pointer to a data or function member of a class or
structure is a unique type.

A debugging information entry representing the type of an object that is a
pointer to a structure or class member has the tag DW_TAG_ptr_to_member_type.

If the pointer to member type has a name, the pointer to member entry has a
DW_AT_name attribute, whose value is a null-terminated string containing the
type name.

The pointer to member entry has a DW_AT_type attribute to describe the type of
the class or structure member to which objects of this type may point.

The entry also has a DW_AT_containing_type attribute, whose value is a reference
to a debugging information entry for the class or structure to whose members
objects of this type may point.

The DW_TAG_ptr_to_member_type debugging information entry has a
DW_AT_use_location attribute whose value is a DWARF expression E. It is used to
compute the location description of the member of the class to which the pointer
to member entry points.

[non-normative] The method used to find the location description of a given
member of a class, structure, or union is common to any instance of that class,
structure, or union and to any instance of the pointer to member type. The
method is thus associated with the pointer to member type, rather than with each
object that has a pointer to member type.

The DW_AT_use_location DWARF expression is used in conjunction with the location
description for a particular object of the given pointer to member type and for
a particular structure or class instance.

The result of the attribute is obtained by evaluating E with a context that has
a result kind of a location description, an unspecified object, the compilation
unit that contains E, an initial stack comprising two entries, and other context
elements corresponding to the source language thread of execution upon which the
user is focused, if any. The first stack entry is the value of the pointer to
member object itself. The second stack entry is the location description of the
base of the entire class, structure, or union instance containing the member
whose location is being calculated. The result of the evaluation is the location
description of the member of the class to which the pointer to member entry
points.

[non-normative] For an expression such as

    object.*mbr_ptr

[non-normative] where mbr_ptr has some pointer to member type, a debugger
should:

1.  [non-normative] Push the value of mbr_ptr onto the DWARF expression stack.

2.  [non-normative] Push the base address of object onto the DWARF expression
    stack.

3.  [non-normative] Evaluate the DW_AT_use_location description given in the
    type of mbr_ptr.

5.18.1 Data Location

[non-normative] Some languages may represent objects using descriptors to hold
information, including a location and/or run-time parameters, about the data
that represents the value for that object.

The DW_AT_data_location attribute may be used with any type that provides one or
more levels of hidden indirection and/or run-time parameters in its
representation. Its value is a DWARF operation expression E which computes the
location description of the data for an object. When this attribute is omitted,
the location description of the data is the same as the location description of
the object.

The result of the attribute is obtained by evaluating E with a context that has
a result kind of a location description, an object that is the location
description of the data descriptor, the compilation unit that contains E, an
empty initial stack, and other context elements corresponding to the source
language thread of execution upon which the user is focused, if any. The result
of the evaluation is the location description of the base of the member entry.

[non-normative] E will typically involve an operation expression that begins
with a DW_OP_push_object_address operation which loads the location description
of the object which can then serve as a descriptor in subsequent calculation.

> [For further discussion...]
> NOTE: Since DW_AT_data_member_location, DW_AT_use_location, and
> DW_AT_vtable_elem_location allow both operation expressions and location list
> expressions, why does DW_AT_data_location not allow both? In all cases they
> apply to data objects so less likely that optimization would cause different
> operation expressions for different program location ranges. But if supporting
> for some then should be for all.
>
> It seems odd this attribute is not the same as DW_AT_data_member_location in
> having an initial stack with the location description of the object since the
> expression has to need it.

6.1.1.1 Contents of the Name Index

The name index must contain an entry for each debugging information entry that
defines a named subprogram, label, variable, type, or namespace, subject to the
following rules:

  * All non-defining declarations (that is, debugging information entries with a
    DW_AT_declaration attribute) are excluded.

  * DW_TAG_namespace debugging information entries without a
    DW_AT_name attribute are included with the name "(anonymous namespace)".

  * All other debugging information entries without a DW_AT_name attribute are
    excluded.

  * DW_TAG_subprogram, DW_TAG_inlined_subroutine, and DW_TAG_label debugging
    information entries without an address attribute (DW_AT_low_pc,
    DW_AT_high_pc, DW_AT_ranges, or DW_AT_entry_pc) are excluded.

  * DW_TAG_variable debugging information entries with a DW_AT_location
    attribute that includes a DW_OP_addr, DW_OP_form_aspace_address, or
    DW_OP_form_tls_address operation are included; otherwise, they are excluded.

  * If a subprogram or inlined subroutine is included, and has a
    DW_AT_linkage_name attribute, there will be an additional index entry for
    the linkage name.

For the purposes of determining whether a debugging information entry has a
particular attribute (such as DW_AT_name), if debugging information entry A has
a DW_AT_specification or DW_AT_abstract_origin attribute pointing to another
debugging information entry B, any attributes of B are considered to be part of
A.

[non-normative] The intent of the above rules is to provide the consumer with
some assurance that looking up an unqualified name in the index will yield all
relevant debugging information entries that provide a defining declaration at
global scope for that name.

[non-normative] A producer may choose to implement additional rules for what
names are placed in the index, and may communicate those rules to a cooperating
consumer via an augmentation string, described below.

6.4.1 Structure of Call Frame Information

DWARF supports virtual unwinding by defining an architecture independent basis
for recording how subprograms save and restore registers during their lifetimes.
This basis must be augmented on some machines with specific information that is
defined by an architecture specific ABI authoring committee, a hardware vendor,
or a compiler producer. The body defining a specific augmentation is referred to
below as the "augmenter."

Abstractly, this mechanism describes a very large table that has the following
structure:

    LOC CFA R0 R1 ... RN
    L0
    L1
    ...
    LN

The first column indicates an address for every location that contains code in a
program. (In shared object files, this is an object-relative offset.) The
remaining columns contain virtual unwinding rules that are associated with the
indicated location.

The CFA column defines the rule which computes the Canonical Frame Address
value; it may be either a register and a signed offset that are added together,
or a DWARF expression that is evaluated.

The remaining columns are labelled by register number. This includes some
registers that have special designation on some architectures such as the PC and
the stack pointer register. (The actual mapping of registers for a particular
architecture is defined by the augmenter.) The register columns contain rules
that describe whether a given register has been saved and the rule to find the
value for the register in the previous frame.

The register rules are:

    undefined
        A register that has this rule has no recoverable value in the previous
        frame. The previous value of this register is the undefined location
        description (see 2.x.x Undefined Location Description Operations).
        
        [non-normative] By convention, the register is not preserved by a
        callee.

    same value
        This register has not been modified from the previous caller frame. 

        If the current frame is the top frame, then the previous value of this
        register is the location description L that specifies one register
        location description SL. SL specifies the register location storage that
        corresponds to the register with a bit offset of 0 for the current
        thread.

        If the current frame is not the top frame, then the previous value of
        this register is the location description obtained using the call frame
        information for the callee frame and callee program location invoked by
        the current caller frame for the same register.

        [non-normative] By convention, the register is preserved by the callee,
        but the callee has not modified it.

    offset(N)
        N is a signed byte offset. The previous value of this register is saved
        at the location description computed as if the DWARF operation
        expression DW_OP_offset N is evaluated with the current context, except
        the result kind is a location description, the compilation unit is
        unspecified, the object is unspecified, and an initial stack comprising
        the location description of the current CFA (see 2.5.4 DWARF Operation
        Expressions).

    val_offset(N)
        N is a signed byte offset. The previous value of this register is the
        memory byte address of the location description computed as if the DWARF
        operation expression DW_OP_offset N is evaluated with the current
        context, except the result kind is a location description, the
        compilation unit is unspecified, the object is unspecified, and an
        initial stack comprising the location description of the current CFA
        (see 2.5.4 DWARF Operation Expressions).

        The DWARF is ill-formed if the CFA location description is not a memory
        byte address location description, or if the register size does not
        match the size of an address in the address space of the current CFA
        location description.

        [non-normative] Since the CFA location description is required to be a
        memory byte address location description, the value of val_offset(N)
        will also be a memory byte address location description since it is
        offsetting the CFA location description by N bytes. Furthermore, the
        value of val_offset(N) will be a memory byte address in the same address
        space as the CFA location description.

        > [For further discussion...]
        > Should DWARF allow the address size to be a different size to the size
        > of the register? Requiring them to be the same bit size avoids any
        > issue of conversion as the bit contents of the register is simply
        > interpreted as a value of the address.
        >
        > GDB has a per register hook that allows a target specific conversion
        > on a register by register basis. It defaults to truncation of bigger
        > registers, and to actually reading bytes from the next register (or
        > reads out of bounds for the last register) for smaller registers.
        > There are no GDB tests that read a register out of bounds (except an
        > illegal hand written assembly test).

    register(R)
        This register has been stored in another register numbered R.

        The previous value of this register is the location description obtained
        using the call frame information for the current frame and current
        program location for register R.

        The DWARF is ill-formed if the size of this register does not match the
        size of register R or if there is a cyclic dependency in the call frame
        information.

        > [For further discussion...]
        > Should this also allow R to be larger than this register? If so is the
        > value stored in the low order bits and it is undefined what is stored
        > in the extra upper bits?

    expression(E)
        The previous value of this register is located at the location
        description produced by evaluating the DWARF operation expression E (see
        2.5.4 DWARF Operation Expressions).

        E is evaluated with the current context, except the result kind is a
        location description, the compilation unit is unspecified, the object is
        unspecified, and an initial stack comprising the location description of
        the current CFA (see 2.5.4 DWARF Operation Expressions).

    val_expression(E)
        The previous value of this register is located at the implicit location
        description created from the value produced by evaluating the DWARF
        operation expression E (see 2.5.4 DWARF Operation Expressions).

        E is evaluated with the current context, except the result kind is a
        value, the compilation unit is unspecified, the object is unspecified,
        and an initial stack comprising the location description of the current
        CFA (see 2.5.4 DWARF Operation Expressions).

        The DWARF is ill-formed if the resulting value type size does not match
        the register size.

        > [For further discussion...]
        > This has limited usefulness as the DWARF expression E can only produce
        > values up to the size of the generic type. This is due to not allowing
        > any operations that specify a type in a CFI operation expression. This
        > makes it unusable for registers that are larger than the generic type.
        > However, expression(E) can be used to create an implicit location
        > description of any size.

    architectural
        The rule is defined externally to this specification by the augmenter.

[non-normative] This table would be extremely large if actually constructed as
described. Most of the entries at any point in the table are identical to the
ones above them. The whole table can be represented quite compactly by recording
just the differences starting at the beginning address of each subroutine in the
program.

The virtual unwind information is encoded in a self-contained section called
.debug_frame. Entries in a .debug_frame section are aligned on a multiple of the
address size relative to the start of the section and come in two forms: a
Common Information Entry (CIE) and a Frame Description Entry (FDE).

[non-normative] If the range of code addresses for a function is not contiguous,
there may be multiple CIEs and FDEs corresponding to the parts of that function.

A Common Information Entry (CIE) holds information that is shared among many
Frame Description Entries (FDE). There is at least one CIE in every non-empty
.debug_frame section. A CIE contains the following fields, in order:

1.  length (initial length)
    A constant that gives the number of bytes of the CIE structure, not
    including the length field itself (see Section 7.2.2 on page 184). The size
    of the length field plus the value of length must be an integral multiple of
    the address size specified in the address_size field.

2.  CIE_id (4 or 8 bytes, see Section 7.4 on page 196)
    A constant that is used to distinguish CIEs from FDEs.

    In the 32-bit DWARF format, the value of the CIE id in the CIE header is
    0xffffffff; in the 64-bit DWARF format, the value is 0xffffffffffffffff.

3.  version (ubyte)
    A version number (see Section 7.24 on page 238). This number is specific to
    the call frame information and is independent of the DWARF version number.

    The value of the CIE version number is 4.

    > [For further discussion...]
    > Should this be increased to 5?

4.  augmentation (sequence of UTF-8 characters)
    A null-terminated UTF-8 string that identifies the augmentation to this CIE
    or to the FDEs that use it. If a reader encounters an augmentation string
    that is unexpected, then only the following fields can be read:

      * CIE: length, CIE_id, version, augmentation

      * FDE: length, CIE_pointer, initial_location, address_range

    If there is no augmentation, this value is a zero byte.

    [non-normative] The augmentation string allows users to indicate that there
    is additional vendor and target architecture specific information in the CIE
    or FDE which is needed to virtually unwind a stack frame. For example, this
    might be information about dynamically allocated data which needs to be
    freed on exit from the routine.

    [non-normative] Because the .debug_frame section is useful independently of
    any .debug_info section, the augmentation string always uses UTF-8 encoding.

5.  address_size (ubyte)
    The size of a target address in this CIE and any FDEs that use it, in bytes.
    If a compilation unit exists for this frame, its address size must match the
    address size here.

6.  segment_selector_size (ubyte)
    The size of a segment selector in this CIE and any FDEs that use it, in
    bytes.

7.  code_alignment_factor (unsigned LEB128)
    A constant that is factored out of all advance location instructions (see
    Section 6.4.2.1 on page 177). The resulting value is (operand *
    code_alignment_factor).

8.  data_alignment_factor (signed LEB128)
    A constant that is factored out of certain offset instructions (see Sections
    6.4.2.2 on page 177 and 6.4.2.3 on page 179). The resulting value is
    (operand * data_alignment_factor).

9.  return_address_register (unsigned LEB128)
    An unsigned LEB128 constant that indicates which column in the rule table
    represents the return address of the subprogram. Note that this column might
    not correspond to an actual machine register.

    The value of the return address register is used to determine the program
    location of the caller frame. The program location of the top frame is the
    target architecture program counter value of the current thread.

10. initial_instructions (array of ubyte)
    A sequence of rules that are interpreted to create the initial setting of
    each column in the table.

    The default rule for all columns before interpretation of the initial
    instructions is the undefined rule. However, an ABI authoring body or a
    compilation system authoring body may specify an alternate default value for
    any or all columns.

11. padding (array of ubyte)
    Enough DW_CFA_nop instructions to make the size of this entry match the
    length value above.

An FDE contains the following fields, in order:

1.  length (initial length)
    A constant that gives the number of bytes of the header and instruction
    stream for this subprogram, not including the length field itself (see
    Section 7.2.2 on page 184). The size of the length field plus the value of
    length must be an integral multiple of the address size.

2.  CIE_pointer (4 or 8 bytes, see Section 7.4 on page 196)
    A constant offset into the .debug_frame section that denotes the CIE that is
    associated with this FDE.

3.  initial_location (segment selector and target address)
    The address of the first location associated with this table entry. If the
    segment_selector_size field of this FDE's CIE is non-zero, the initial
    location is preceded by a segment selector of the given length.

4.  address_range (target address)
    The number of bytes of program instructions described by this entry.

5.  instructions (array of ubyte)
    A sequence of table defining instructions that are described in Section
    6.4.2.

6.  padding (array of ubyte)
    Enough DW_CFA_nop instructions to make the size of this entry match the
    length value above.

6.4.2 Call Frame Instructions

Each call frame instruction is defined to take 0 or more operands. Some of the
operands may be encoded as part of the opcode (see Section 7.24 on page 238).
The instructions are defined in the following sections.

Some call frame instructions have operands that are encoded as DWARF operation
expressions E (see Section 2.5.1 on page 26). The DWARF operations that can be
used in E have the following restrictions:

  * DW_OP_addrx, DW_OP_call2, DW_OP_call4, DW_OP_call_ref, DW_OP_const_type,
    DW_OP_constx, DW_OP_convert, DW_OP_deref_type, DW_OP_fbreg,
    DW_OP_implicit_pointer, DW_OP_regval_type, DW_OP_reinterpret, and
    DW_OP_xderef_type operations are not allowed because the call frame
    information must not depend on other debug sections.

  * DW_OP_push_object_address is not allowed because there is no object context
    to provide a value to push.

  * DW_OP_push_lane is not allowed because the call frame instructions
    describe the actions for the whole target architecture thread, not the
    lanes independently.

  * DW_OP_call_frame_cfa and DW_OP_entry_value are not allowed because their
    use would be circular.

  * DW_OP_call_frame_entry_reg is not allowed if evaluating E causes a circular
    dependency between DW_OP_call_frame_entry_reg operations.

    [non-normative] For example, if a register R1 has a
    DW_CFA_def_cfa_expression instruction that evaluates a
    DW_OP_call_frame_entry_reg operation that specifies register R2, and
    register R2 has a DW_CFA_def_cfa_expression instruction that that evaluates
    a DW_OP_call_frame_entry_reg operation that specifies register R1.

[non-normative] Call frame instructions to which these restrictions apply
include DW_CFA_def_cfa_expression, DW_CFA_expression, and DW_CFA_val_expression.

6.4.2.1 Row Creation Instructions

...

6.4.2.2 CFA Definition Instructions

1.  DW_CFA_def_cfa
    The DW_CFA_def_cfa instruction takes two unsigned LEB128 operands
    representing a register number R and a (non-factored) byte displacement B.
    AS is set to the target architecture default address space identifier. The
    required action is to define the current CFA rule to be equivalent to the
    result of evaluating the DWARF operation expression DW_OP_constu AS;
    DW_OP_aspace_bregx R, B as a location description.

2.  DW_CFA_def_cfa_sf
    The DW_CFA_def_cfa_sf instruction takes two operands: an unsigned LEB128
    value representing a register number R and a signed LEB128 factored byte
    displacement B. AS is set to the target architecture default address space
    identifier. The required action is to define the current CFA rule to be
    equivalent to the result of evaluating the DWARF operation expression
    DW_OP_constu AS; DW_OP_aspace_bregx R, B * data_alignment_factor as a
    location description.

    [non-normative] The action is the same as DW_CFA_def_cfa, except that the
    second operand is signed and factored.

3.  DW_CFA_def_aspace_cfa
    The DW_CFA_def_aspace_cfa instruction takes three unsigned LEB128 operands
    representing a register number R, a (non-factored) byte displacement B, and
    a target architecture specific address space identifier AS. The required
    action is to define the current CFA rule to be equivalent to the result of
    evaluating the DWARF operation expression DW_OP_constu AS;
    DW_OP_aspace_bregx R, B as a location description.

    If AS is not one of the values defined by the target architecture specific
    DW_ASPACE_* values then the DWARF expression is ill-formed.

4.  DW_CFA_def_aspace_cfa_sf
    The DW_CFA_def_aspace_cfa_sf instruction takes three operands: an unsigned
    LEB128 value representing a register number R, a signed LEB128 factored byte
    displacement B, and an unsigned LEB128 value representing a target
    architecture specific address space identifier AS. The required action is to
    define the current CFA rule to be equivalent to the result of evaluating the
    DWARF operation expression DW_OP_constu AS; DW_OP_aspace_bregx R, B *
    data_alignment_factor as a location description.

    If AS is not one of the values defined by the target architecture specific
    DW_ASPACE_* values, then the DWARF expression is ill-formed.

    [non-normative] The action is the same as DW_CFA_aspace_def_cfa, except that
    the second operand is signed and factored.

5.  DW_CFA_def_cfa_register
    The DW_CFA_def_cfa_register instruction takes a single unsigned LEB128
    operand representing a register number R. The required action is to define
    the current CFA rule to be equivalent to the result of evaluating the DWARF
    operation expression DW_OP_constu AS; DW_OP_aspace_bregx R, B as a location
    description. B and AS are the old CFA byte displacement and address space
    respectively.

    If the subprogram has no current CFA rule, or the rule was defined by a
    DW_CFA_def_cfa_expression instruction, then the DWARF is ill-formed.

6.  DW_CFA_def_cfa_offset
    The DW_CFA_def_cfa_offset instruction takes a single unsigned LEB128 operand
    representing a (non-factored) byte displacement B. The required action is to
    define the current CFA rule to be equivalent to the result of evaluating the
    DWARF operation expression DW_OP_constu AS; DW_OP_aspace_bregx R, B as a
    location description. R and AS are the old CFA register number and address
    space respectively.

    If the subprogram has no current CFA rule, or the rule was defined by a
    DW_CFA_def_cfa_expression instruction, then the DWARF is ill-formed.

7.  DW_CFA_def_cfa_offset_sf
    The DW_CFA_def_cfa_offset_sf instruction takes a signed LEB128 operand
    representing a factored byte displacement B. The required action is to
    define the current CFA rule to be equivalent to the result of evaluating the
    DWARF operation expression DW_OP_constu AS; DW_OP_aspace_bregx R, B *
    data_alignment_factor as a location description. R and AS are the old CFA
    register number and address space respectively.

    If the subprogram has no current CFA rule, or the rule was defined by a
    DW_CFA_def_cfa_expression instruction, then the DWARF is ill-formed.

    [non-normative] The action is the same as DW_CFA_def_cfa_offset, except
    that the operand is signed and factored.

8.  DW_CFA_def_cfa_expression
    The DW_CFA_def_cfa_expression instruction takes a single operand encoded as
    a DW_FORM_exprloc value representing a DWARF operation expression E. The
    required action is to define the current CFA rule to be equivalent to the
    result of evaluating E with the current context, except the result kind is a
    location description, the compilation unit is unspecified, the object is
    unspecified, and an empty initial stack.

    [non-normative] See 6.4.2 Call Frame Instructions regarding restrictions on
    the DWARF expression operations that can be used in E.

    The DWARF is ill-formed if the result of evaluating E is not a memory byte
    address location description.

6.4.2.3 Register Rule Instructions

1.  DW_CFA_undefined
    The DW_CFA_undefined instruction takes a single unsigned LEB128 operand
    that represents a register number R. The required action is to set the rule
    for the register specified by R to "undefined."

2.  DW_CFA_same_value
    The DW_CFA_same_value instruction takes a single unsigned LEB128 operand
    that represents a register number R. The required action is to set the rule
    for the register specified by R to "same value."

3.  DW_CFA_offset
	The DW_CFA_offset instruction takes two operands: a register number R
	(encoded with the opcode) and an unsigned LEB128 constant representing a
	factored displacement B. The required action is to change the rule for the
	register specified by R to be an offset(B * data_alignment_factor) rule.

4.  DW_CFA_offset_extended
    The DW_CFA_offset_extended instruction takes two unsigned LEB128 operands
    representing a register number R and a factored displacement B. This
    instruction is identical to DW_CFA_offset, except for the encoding and size
    of the register operand.

5.  DW_CFA_offset_extended_sf
    The DW_CFA_offset_extended_sf instruction takes two operands: an unsigned
    LEB128 value representing a register number R and a signed LEB128 factored
    displacement B. This instruction is identical to DW_CFA_offset_extended,
    except that B is signed.

6.  DW_CFA_val_offset
    The DW_CFA_val_offset instruction takes two unsigned LEB128 operands
    representing a register number R and a factored displacement B. The required
    action is to change the rule for the register indicated by R to be a
    val_offset(B * data_alignment_factor) rule.

7.  DW_CFA_val_offset_sf
    The DW_CFA_val_offset_sf instruction takes two operands: an unsigned LEB128
    value representing a register number R and a signed LEB128 factored
    displacement B. This instruction is identical to DW_CFA_val_offset, except
    that B is signed.

8.  DW_CFA_register
	The DW_CFA_register instruction takes two unsigned LEB128 operands
	representing register numbers R1 and R2 respectively. The required action is
	to set the rule for the register specified by R1 to be a register(R2) rule.

9.  DW_CFA_expression
    The DW_CFA_expression instruction takes two operands: an unsigned LEB128
    value representing a register number R, and a DW_FORM_block value
    representing a DWARF operation expression E. The required action is to
    change the rule for the register specified by R to be an expression(E) rule.

    [non-normative] That is, E computes the location description where the
    register value can be retrieved.

    [non-normative] See Section 6.4.2 on page 176 regarding restrictions on the
    DWARF expression operations that can be used in E.

10. DW_CFA_val_expression
    The DW_CFA_val_expression instruction takes two operands: an unsigned
    LEB128 value representing a register number R, and a DW_FORM_block value
    representing a DWARF operation expression E. The required action is to
    change the rule for the register specified by R to be a val_expression(E)
    rule.
    
    [non-normative] That is, E computes the value of register R.

    [non-normative] See 6.4.2 Call Frame Instructions regarding restrictions on
    the DWARF expression operations that can be used in E.

    If the result of evaluating E is not a value with a base type size that
    matches the register size, then the DWARF is ill-formed.

11. DW_CFA_restore
    The DW_CFA_restore instruction takes a single operand (encoded with the
    opcode) that represents a register number R. The required action is to
    change the rule for the register specified by R to the rule assigned it by
    the initial_instructions in the CIE.

12. DW_CFA_restore_extended
    The DW_CFA_restore_extended instruction takes a single unsigned LEB128
    operand that represents a register number R. This instruction is identical
    to DW_CFA_restore, except for the encoding and size of the register operand.

7.4 32-Bit and 64-Bit DWARF Formats

...

3.  Within the body of the .debug_info section, certain forms of attribute value
    depend on the choice of DWARF format as follows. For the 32-bit DWARF
    format, the value is a 4-byte unsigned integer; for the 64-bit DWARF format,
    the value is an 8-byte unsigned integer.

    ------------------------------ ------------------------------
	Form                           Role
    ------------------------------ ------------------------------
	DW_FORM_line_strp              offset in .debug_line_str
	DW_FORM_ref_addr               offset in .debug_info
	DW_FORM_sec_offset             offset in a section other than
                                   .debug_info or .debug_str
	DW_FORM_strp                   offset in .debug_str
    DW_FORM_strp_sup               offset in .debug_str section of a
                                   supplementary object file
    DW_OP_call_ref                 offset in .debug_info
    DW_OP_implicit_pointer         offset in .debug_info
    DW_OP_aspace_implicit_pointer  offset in .debug_info
    ------------------------------ ------------------------------

...

7.5.4 Attribute Encodings

The encodings for the attribute names are given in Table 7.5 following.

Table 7.5: Attribute encodings
---------------------------------- ------ -----------------
Attribute name                     Value  Classes
---------------------------------- ------ -----------------
...
DW_AT_address_space                TBA    constant
DW_AT_memory_space                 TBA    constant
DW_AT_lanes                        TBA    constant, exprloc, loclist
DW_AT_active_lane                  TBA    exprloc, loclist
DW_AT_lane_pc                      TBA    exprloc, loclist
DW_AT_vector_size                  TBA    constant
---------------------------------- ------ -----------------

7.5.5 Classes and Forms

...

  * reference
    There are four types of reference.

      - The first type of reference...

      - The second type of reference can identify any debugging information
        entry within a .debug_info section; in particular, it may refer to an
        entry in a different compilation unit from the unit containing the
        reference, and may refer to an entry in a different shared object file.
        This type of reference (DW_FORM_ref_addr) is an offset from the
        beginning of the .debug_info section of the target executable or shared
        object file, or, for references within a supplementary object file, an
        offset from the beginning of the local .debug_info section; it is
        relocatable in a relocatable object file and frequently relocated in an
        executable or shared object file. In the 32-bit DWARF format, this
        offset is a 4-byte unsigned value; in the 64-bit DWARF format, it is an
        8-byte unsigned value (see Section 7.4 on page 196).

        [non-normative] A debugging information entry that may be referenced by
        another compilation unit using DW_FORM_ref_addr must have a global
        symbolic name.

        [non-normative] For a reference from one executable or shared object
        file to another, the reference is resolved by the debugger to identify
        the executable or shared object file and the offset into that file's
        .debug_info section in the same fashion as the run time loader, either
        when the debug information is first read, or when the reference is used.

7.7 DWARF Expressions

7.7.1 Operation Expressions

A DWARF operation expression is stored in a block of contiguous bytes. The bytes
form a sequence of operations. Each operation is a 1-byte code that identifies
that operation, followed by zero or more bytes of additional data. The encodings
for the operations are described in Table 7.9.

Table 7.9: DWARF operation encodings
---------------------------------- ----- --------- ---------------------------
                                         No. of
Operation                          Code  Operands  Notes
---------------------------------- ----- --------- ---------------------------
...
DW_OP_offset                       TBA      0
DW_OP_offset_uconst                TBA      1      ULEB128 byte displacement
DW_OP_bit_offset                   TBA      0
DW_OP_undefined                    TBA      0
DW_OP_piece_end                    TBA      0
DW_OP_form_aspace_address          TBA      0
DW_OP_aspace_bregx                 TBA      2      ULEB128 register number,
                                                   ULEB128 byte displacement
DW_OP_aspace_implicit_pointer      TBA      2      4-byte or 8-byte offset of
                                                   DIE, SLEB128 byte
                                                   displacement
DW_OP_overlay                      TBA      0
DW_OP_bit_overlay                  TBA      0
DW_OP_extend                       TBA      2      ULEB128 bit size,
                                                   ULEB128 count
DW_OP_select_bit_piece             TBA      2      ULEB128 bit size,
                                                   ULEB128 count
DW_OP_call_frame_entry_reg         TBA      1      ULEB128 register number
DW_OP_push_lane                    TBA      0
---------------------------------- ----- --------- ---------------------------

7.7.2 Location List Expressions

...

7.12 Source Languages

The encodings of the constants used in the DW_AT_language attribute are given in
Table 7.17. Names marked with † and their associated values are reserved, but
the languages they represent are not well supported. Table 7.17 also shows the
default lower bound, if any, assumed for an omitted DW_AT_lower_bound attribute
in the context of a DW_TAG_subrange_type debugging information entry for each
defined language.

Table 7.17: Language encodings
-------------------- ------ -------------------
Language name        Value  Default Lower Bound
-------------------- ------ -------------------
...
DW_LANG_HIP          TBA    0
-------------------- ------ -------------------

7.13 Address Class Encodings

The value of the common address class encoding DW_ADDR_none is 0.

7.14 Address Space Encodings

The value of the common address space encoding DW_ASPACE_none is 0.

7.15 Memory Space Encodings

The encodings of the constants used for the currently defined memory spaces
are given in Table 7.x "Memory space encodings".

Table 7.x: Memory space encodings

========================== ======
Memory Space Name          Value
========================== ======
DW_MSPACE_none             0x0000
DW_MSPACE_global           0x0001
DW_MSPACE_constant         0x0002
DW_MSPACE_group            0x0003
DW_MSPACE_private          0x0004
DW_MSPACE_lo_user          0x8000
DW_MSPACE_hi_user          0xffff
========================== ======

7.24 Call Frame Information

In the 32-bit DWARF format, the value of the CIE id in the CIE header is
0xffffffff; in the 64-bit DWARF format, the value is 0xffffffffffffffff.

The value of the CIE version number is 4.

Call frame instructions are encoded in one or more bytes. The primary opcode is
encoded in the high order two bits of the first byte (that is, opcode = byte ≫
6). An operand or extended opcode may be encoded in the low order 6 bits.
Additional operands are encoded in subsequent bytes. The instructions and their
encodings are presented in Table 7.29 on the following page.

Table 7.29: Call frame instruction encodings
------------------------ ------- ------ ---------------- ---------------- ----------------
                         High 2  Low 6
Instruction              Bits    Bits   Operand 1        Operand 2        Operand 3
------------------------ ------- ------ ---------------- ---------------- ----------------
...
DW_CFA_def_aspace_cfa    0       TBA    ULEB128 register ULEB128 offset   ULEB128 address space
DW_CFA_def_aspace_cfa_sf 0       TBA    ULEB128 register SLEB128 offset   ULEB128 address space
------------------------ ------- ------ ---------------- ---------------- ----------------

7.32 Type Signature Computation

Table 7.32: Attributes used in type signature computation
---------------------------------------------------------
...
DW_AT_address_space
...
DW_AT_memory_space
...
DW_AT_vector_size
...
---------------------------------------------------------

Appendix A

Attributes by Tag Value (Informative)

...

Table A.1: Attributes by tag value
------------------------------ -------------------------------------
TAG name                       Applicable attributes
------------------------------ -------------------------------------
...
DW_TAG_base_type               DW_AT_vector_size
DW_TAG_pointer_type            DW_AT_address_space
                               DW_AT_memory_space
DW_TAG_reference_type          DW_AT_address_space
                               DW_AT_memory_space
DW_TAG_rvalue_reference_type   DW_AT_address_space
                               DW_AT_memory_space
DW_TAG_variable                DW_AT_memory_space
DW_TAG_formal_parameter        DW_AT_memory_space
DW_TAG_constant                DW_AT_memory_space
DW_TAG_entry_point             DW_AT_lanes
                               DW_AT_active_lane
                               DW_AT_lane_pc
DW_TAG_inlined_subroutine      DW_AT_lanes
                               DW_AT_active_lane
                               DW_AT_lane_pc
DW_TAG_subprogram              DW_AT_lanes
                               DW_AT_active_lane
                               DW_AT_lane_pc
------------------------------ -------------------------------------

Appendix D

Examples (Informative)

D.1.3 DWARF Location Description Examples

...

DW_OP_offset_uconst 4
    A structure member is four bytes from the start of the structure instance.
    The location description of the base of the structure instance is assumed
    to be already on the stack.

...

DW_OP_entry_value 1 DW_OP_reg5 DW_OP_offset_uconst 16
    The address of the memory location is calculated by adding 16 to the value
    contained in register 5 upon entering the current subprogram.

...

D.2.1 Fortran Simple Array Example

...

-------------------------------------------------------------------------------
! Description for type of 'ap'
!
1$: DW_TAG_array_type
        ! No name, default (Fortran) ordering, default stride
        DW_AT_type(reference to REAL)
        DW_AT_associated(expression=    ! Test 'ptr_assoc' flag
            DW_OP_push_object_address
            DW_OP_lit<n>                ! where n == offset(ptr_assoc)
            DW_OP_offset
            DW_OP_deref
            DW_OP_lit1                  ! mask for 'ptr_assoc' flag
            DW_OP_and)
        DW_AT_data_location(expression= ! Get raw data address
            DW_OP_push_object_address
            DW_OP_lit<n>                ! where n == offset(base)
            DW_OP_offset
            DW_OP_deref)                ! Type of index of array 'ap'
2$:     DW_TAG_subrange_type
            ! No name, default stride
            DW_AT_type(reference to INTEGER)
            DW_AT_lower_bound(expression=
                DW_OP_push_object_address
                DW_OP_lit<n>            ! where n ==
                                        !   offset(desc, dims) +
                                        !   offset(dims_str, lower_bound)
                DW_OP_offset
                DW_OP_deref)
            DW_AT_upper_bound(expression=
                DW_OP_push_object_address
                DW_OP_lit<n>            ! where n ==
                                        !   offset(desc, dims) +
                                        !   offset(dims_str, upper_bound)
                DW_OP_offset
                DW_OP_deref)
!  Note: for the m'th dimension, the second operator becomes
!  DW_OP_lit<n> where
!       n == offset(desc, dims)          +
!                (m-1)*sizeof(dims_str)  +
!                 offset(dims_str, [lower|upper]_bound)
!  That is, the expression does not get longer for each successive
!  dimension (other than to express the larger offsets involved).
3$: DW_TAG_structure_type
        DW_AT_name("array_ptr")
        DW_AT_byte_size(constant sizeof(REAL) + sizeof(desc<1>))
4$:     DW_TAG_member
            DW_AT_name("myvar")
            DW_AT_type(reference to REAL)
            DW_AT_data_member_location(constant 0)
5$:     DW_TAG_member
            DW_AT_name("ap");
            DW_AT_type(reference to 1$)
            DW_AT_data_member_location(constant sizeof(REAL))
6$: DW_TAG_array_type
        ! No name, default (Fortran) ordering, default stride
        DW_AT_type(reference to 3$)
        DW_AT_allocated(expression=       ! Test 'ptr_alloc' flag
            DW_OP_push_object_address
            DW_OP_lit<n>                  ! where n == offset(ptr_alloc)
            DW_OP_offset
            DW_OP_deref
            DW_OP_lit2                    ! Mask for 'ptr_alloc' flag
            DW_OP_and)
        DW_AT_data_location(expression=   ! Get raw data address
            DW_OP_push_object_address
            DW_OP_lit<n>                  ! where n == offset(base)
            DW_OP_offset
            DW_OP_deref)
7$:     DW_TAG_subrange_type
            ! No name, default stride
            DW_AT_type(reference to INTEGER)
            DW_AT_lower_bound(expression=
                DW_OP_push_object_address
                DW_OP_lit<n>              ! where n == ...
                DW_OP_offset
                DW_OP_deref)
            DW_AT_upper_bound(expression=
                DW_OP_push_object_address
                DW_OP_lit<n>              ! where n == ...
                DW_OP_offset
                DW_OP_deref)
8$: DW_TAG_variable
        DW_AT_name("arrayvar")
        DW_AT_type(reference to 6$)
        DW_AT_location(expression=
            ...as appropriate...)         ! Assume static allocation
-------------------------------------------------------------------------------
Figure D.4: Fortran array example: DWARF description

...

D.2.3 Fortran 2008 Assumed-rank Array Example

...

----------------------------------------------------------------------------
10$:  DW_TAG_array_type
        DW_AT_type(reference to real)
        DW_AT_rank(expression=
            DW_OP_push_object_address
            DW_OP_lit<n>
            DW_OP_offset
            DW_OP_deref)
        DW_AT_data_location(expression=
            DW_OP_push_object_address
            DW_OP_lit<n>
            DW_OP_offset
            DW_OP_deref)
11$:     DW_TAG_generic_subrange
            DW_AT_type(reference to integer)
            !   offset of rank in descriptor
            !   offset of data in descriptor
            DW_AT_lower_bound(expression=
            !   Looks up the lower bound of dimension i.
            !   Operation                       ! Stack effect
            !   (implicit)                      ! i
                DW_OP_lit<n>                    ! i sizeof(dim)
                DW_OP_mul                       ! dim[i]
                DW_OP_lit<n>                    ! dim[i] offsetof(dim)
                DW_OP_plus                      ! dim[i]+offset
                DW_OP_push_object_address       ! dim[i]+offsetof(dim) objptr
                DW_OP_swap                      ! objptr dim[i]+offsetof(dim)
                DW_OP_offset                    ! objptr.dim[i]
                DW_OP_lit<n>                    ! objptr.dim[i] offsetof(lb)
                DW_OP_offset                    ! objptr.dim[i].lowerbound
                DW_OP_deref)                    ! *objptr.dim[i].lowerbound
            DW_AT_upper_bound(expression=
            !   Looks up the upper bound of dimension i.
                DW_OP_lit<n>                    ! sizeof(dim)
                DW_OP_mul
                DW_OP_lit<n>                    ! offsetof(dim)
                DW_OP_plus
                DW_OP_push_object_address
                DW_OP_swap
                DW_OP_offset
                DW_OP_lit<n>                    ! offset of upperbound in dim
                DW_OP_offset
                DW_OP_deref)
            DW_AT_byte_stride(expression=
            !   Looks up the byte stride of dimension i.
                ...
            !   (analogous to DW_AT_upper_bound)
                )
----------------------------------------------------------------------------
Figure D.13: Sample DWARF for the array descriptor in Figure D.12

> [For further discussion...]
> This example suggests that DW_AT_lower_bound and DW_AT_upper_bound evaluate an
> exprloc with an initial stack containing the rank value. The attribute
> definition should be updated to state this.

...

D.2.6 Ada Example

...

----------------------------------------------------------------------------
11$:  DW_TAG_variable
          DW_AT_name("M")
          DW_AT_type(reference to INTEGER)
12$:  DW_TAG_array_type
          ! No name, default (Ada) order, default stride
          DW_AT_type(reference to INTEGER)
13$:      DW_TAG_subrange_type
              DW_AT_type(reference to INTEGER)
              DW_AT_lower_bound(constant 1)
              DW_AT_upper_bound(reference to variable M at 11$)
14$:  DW_TAG_variable
          DW_AT_name("VEC1")
          DW_AT_type(reference to array type at 12$)
      ...
21$:  DW_TAG_subrange_type
          DW_AT_name("TEENY")
          DW_AT_type(reference to INTEGER)
          DW_AT_lower_bound(constant 1)
          DW_AT_upper_bound(constant 100)
      ...
26$:  DW_TAG_structure_type
          DW_AT_name("REC2")
27$:      DW_TAG_member
              DW_AT_name("N")
              DW_AT_type(reference to subtype TEENY at 21$)
              DW_AT_data_member_location(constant 0)
28$:      DW_TAG_array_type
              ! No name, default (Ada) order, default stride
              ! Default data location
              DW_AT_type(reference to INTEGER)
29$:          DW_TAG_subrange_type
                  DW_AT_type(reference to subrange TEENY at 21$)
                  DW_AT_lower_bound(constant 1)
                  DW_AT_upper_bound(reference to member N at 27$)
30$:      DW_TAG_member
              DW_AT_name("VEC2")
              DW_AT_type(reference to array "subtype" at 28$)
              DW_AT_data_member_location(machine=
                  DW_OP_lit<n>                ! where n == offset(REC2, VEC2)
                  DW_OP_offset)
      ...
41$:  DW_TAG_variable
          DW_AT_name("OBJ2B")
          DW_AT_type(reference to REC2 at 26$)
          DW_AT_location(...as appropriate...)
----------------------------------------------------------------------------
Figure D.20: Ada example: DWARF description
